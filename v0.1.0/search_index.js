var documenterSearchIndex = {"docs":
[{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/master/examples/unscented_perfect_convective_adjustment_calibration.jl\"","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/#Perfect-convective-adjustment-calibration-with-Unscented-Ensemble-Kalman-Inversion","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"This example calibrates a convective adjustment model in the \"perfect model context\". In this context, synthetic observations are generated by a convective adjustment model with \"true\" parameters. The true parameters are then \"rediscovered\" by calibrating the model to match the synthetic observations.","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"We use the discrepency between observed and modeled buoyancy b to calibrate the convective adjustment model. The calibration problem is solved by Ensemble Kalman Inversion. For more information about Ensemble Kalman Inversion, see the EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"The calibration is done here using Unscented Kalman Inversion. For more information about the algorithm refer to EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/#Install-dependencies","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"We load some packages,","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"using OceanTurbulenceParameterEstimation\nusing LinearAlgebra\nusing EnsembleKalmanProcesses.ParameterDistributionStorage","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"and reuse some some code from a previous example to generate observations,","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"examples_path = joinpath(pathof(OceanTurbulenceParameterEstimation), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_inverse_problems.jl\"))\n\ndata_path = generate_synthetic_observations()\nobservations = OneDimensionalTimeSeries(data_path, field_names=:b, normalize=ZScore)","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/#Free-parameters","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Free parameters","text":"","category":"section"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"We construct some prior distributions for our free parameters. We found that it often helps to constrain the prior distributions so that neither very high nor very low values for diffusivities can be drawn out of the distribution.","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"priors = (\n    convective_κz = ConstrainedNormal(0.0, 1.0, 0.0, 4 * θ★.convective_κz),\n    background_κz = ConstrainedNormal(0.0, 1.0, 0.0, 4 * θ★.background_κz)\n)\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"and an ensemble_simulation,","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"Nparameters = length(priors)\nNensemble = 2 * Nparameters + 1\n\nensemble_simulation, closure★ = build_ensemble_simulation(observations; Nensemble)","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"To visualize the prior distributions we randomly sample out values from then and plot the p.d.f.","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"using CairoMakie\nusing OceanTurbulenceParameterEstimation.EnsembleKalmanInversions: convert_prior, inverse_parameter_transform\n\nsamples(prior) = [inverse_parameter_transform(prior, x) for x in rand(convert_prior(prior), 50000000)]\n\nsamples_convective_κz = samples(priors.convective_κz)\nsamples_background_κz = samples(priors.background_κz)\n\nf = Figure()\n\naxtop = Axis(f[1, 1],\n             xlabel = \"convective_κz [m² s⁻¹]\",\n             ylabel = \"p.d.f.\")\n\naxbottom = Axis(f[2, 1],\n                xlabel = \"background_κz [m² s⁻¹]\",\n                ylabel = \"p.d.f.\")\n\ndensities = []\n\npush!(densities, density!(axtop, samples_convective_κz))\npush!(densities, density!(axbottom, samples_background_κz))\n\nsave(\"visualize_prior_diffusivities_convective_adjustment_uki.svg\", f); nothing #hide","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/#The-inverse-problem","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"The inverse problem","text":"","category":"section"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"We can construct the inverse problem y = G(θ) + η. Here, y are the observations and G is the ensemble_model.","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"Next, we construct an UnscentedKalmanInversion (UKI) object,","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"prior_mean = fill(0.0, Nparameters)\nprior_cov = Matrix(Diagonal(fill(1.0, Nparameters)))\nα_reg = 1.0   # regularization parameter\nupdate_freq = 1\nnoise_covariance = 0.05^2  # error is about 5%\n\nuki = UnscentedKalmanInversion(calibration, prior_mean, prior_cov;\n                               noise_covariance = noise_covariance, α_reg = α_reg, update_freq = update_freq)","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"iterate!(uki; iterations = 10)","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"Last, we visualize the outputs of UKI calibration:","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"θ_mean, θθ_cov, θθ_std_arr, error =  UnscentedKalmanInversionPostprocess(uki)\n\nN_iter = size(θ_mean, 2)\n\nf = Figure(resolution = (800, 600))\nax1 = Axis(f[1, 1],\n           xlabel = \"iterations\",\n           xticks = 1:N_iter,\n           ylabel = \"convective_κz [m² s⁻¹]\")\n\nax2 = Axis(f[2, 1],\n           xlabel = \"iterations\",\n           xticks = 1:N_iter,\n           ylabel = \"background_κz [m² s⁻¹]\")\n\nband!(ax1, 1:N_iter, θ_mean[1, :] .+ θθ_std_arr[1, :], θ_mean[1, :] .- θθ_std_arr[1, :])\nlines!(ax1, Float64.(1:N_iter), θ_mean[1, :])\nhlines!(ax1, [θ★.convective_κz], color=:red)\n\nband!(ax2, 1:N_iter, θ_mean[2, :] .+ θθ_std_arr[2, :], θ_mean[2, :] .- θθ_std_arr[2, :])\nlines!(ax2, 1:N_iter, θ_mean[2, :])\nhlines!(ax2, [θ★.background_κz], color=:red)\n\nxlims!(ax1, 0.5, N_iter+0.5)\nxlims!(ax2, 0.5, N_iter+0.5)\n\nsave(\"uki_results.svg\", f); nothing #hide","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"and the error:","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"f = Figure(resolution = (800, 300))\n\nlines(f[1, 1], 2:N_iter, error, color = :red, linewidth = 2,\n               axis = (xlabel = \"iterations\",\n                       xticks = 1:N_iter,\n                       ylabel = \"error\"))\n\nxlims!(0.5, N_iter+0.5)\n\nsave(\"uki_error.svg\", f); nothing #hide","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/unscented_perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Unscented Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/master/examples/intro_to_inverse_problems.jl\"","category":"page"},{"location":"literated/intro_to_inverse_problems/#Intro-to-InverseProblem","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"This example illustrates the construction of an \"ensemble simulation\" that can evaluate an ensemble of column models given an ensemble of free parameter sets. The example then builds an InverseProblem from observations, an ensemble simulation, and a set of free parameters, and illustrates its basic usage.","category":"page"},{"location":"literated/intro_to_inverse_problems/#Install-dependencies","page":"Intro to InverseProblem","title":"Install dependencies","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"First we load few things","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"using OceanTurbulenceParameterEstimation\n\nusing Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.Models.HydrostaticFreeSurfaceModels: ColumnEnsembleSize\nusing Oceananigans.TurbulenceClosures: ConvectiveAdjustmentVerticalDiffusivity\n\nusing CairoMakie\nusing Distributions\nusing JLD2","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"We reuse some utilities from a previous example to build observations:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"examples_path = joinpath(pathof(OceanTurbulenceParameterEstimation), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_observations.jl\"))\ndata_path = generate_synthetic_observations()\nobservations = OneDimensionalTimeSeries(data_path, field_names=:b, normalize=ZScore)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Building-an-\"ensemble-simulation\"","page":"Intro to InverseProblem","title":"Building an \"ensemble simulation\"","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"Our next task is to construct a parameterized Oceananigans.Simulation that generates the \"foward map\" for an ensemble of free parameter sets. To generate an ensemble of column model model outputs efficiently, we construct one 3D Oceananigans.Simulation consisting of Nx by Ny independent column models.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"The calibration problem then uses the ensemble simulation to find optimal parameters by minimizing the discrepency between the observations and the forward map.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"\"\"\"\n    extract_perfect_parameters(observations, Nensemble)\n\nExtract parameters from a batch of \"perfect\" observations.\n\"\"\"\nfunction extract_perfect_parameters(observations, Nensemble)\n    Nbatch = length(observations)\n    Qᵘ, Qᵇ, N², f = [zeros(Nensemble, Nbatch) for i = 1:4]\n\n    Nz = first(observations).grid.Nz\n    Hz = first(observations).grid.Hz\n    Lz = first(observations).grid.Lz\n    Δt = first(observations).metadata.parameters.Δt\n\n    for (j, obs) in enumerate(observations)\n        Qᵘ[:, j] .= obs.metadata.parameters.Qᵘ\n        Qᵇ[:, j] .= obs.metadata.parameters.Qᵇ\n        N²[:, j] .= obs.metadata.parameters.N²\n        f[:, j] .= obs.metadata.coriolis.f\n    end\n\n    file = jldopen(first(observations).path)\n    closure = file[\"serialized/closure\"]\n    close(file)\n\n    return Qᵘ, Qᵇ, N², f, Δt, Lz, Nz, Hz, closure\nend\n\n\"\"\"\n    build_ensemble_simulation(observations; Nensemble=1)\n\nReturns an `Oceananigans.Simulation` representing an `Nensemble × 1`\nensemble of column models designed to reproduce `observations`.\n\"\"\"\nfunction build_ensemble_simulation(observations; Nensemble=1)\n\n    observations isa Vector || (observations = [observations]) # Singleton batch\n    Nbatch = length(observations)\n\n    Qᵘ, Qᵇ, N², f, Δt, Lz, Nz, Hz, closure = extract_perfect_parameters(observations, Nensemble)\n\n    column_ensemble_size = ColumnEnsembleSize(Nz=Nz, ensemble=(Nensemble, Nbatch), Hz=Hz)\n    ensemble_grid = RectilinearGrid(size = column_ensemble_size, topology = (Flat, Flat, Bounded), z = (-Lz, 0))\n\n    coriolis_ensemble = [FPlane(f=f[i, j]) for i = 1:Nensemble, j=1:Nbatch]\n    closure_ensemble = [deepcopy(closure) for i = 1:Nensemble, j=1:Nbatch]\n\n    u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ))\n    b_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵇ), bottom = GradientBoundaryCondition(N²))\n\n    tracers = first(observations).metadata.parameters.tracers\n\n    ensemble_model = HydrostaticFreeSurfaceModel(grid = ensemble_grid,\n                                                 tracers = tracers,\n                                                 buoyancy = BuoyancyTracer(),\n                                                 boundary_conditions = (; u=u_bcs, b=b_bcs),\n                                                 coriolis = coriolis_ensemble,\n                                                 closure = closure_ensemble)\n\n    ensemble_simulation = Simulation(ensemble_model; Δt=Δt, stop_time=first(observations).times[end])\n\n    return ensemble_simulation, closure\nend","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"The following illustrations uses a simple ensemble simulation with two ensemble members:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"ensemble_simulation, closure★ = build_ensemble_simulation(observations; Nensemble=3)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Free-parameters","page":"Intro to InverseProblem","title":"Free parameters","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"We construct some prior distributions for our free parameters. We found that it often helps to constrain the prior distributions so that neither very high nor very low values for diffusivities can be drawn out of the distribution.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"priors = (convective_κz = lognormal_with_mean_std(0.3, 0.05),\n          background_κz = lognormal_with_mean_std(2.5e-4, 0.25e-4))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"We also take the opportunity to collect a named tuple of the optimal parameters","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"θ★ = (convective_κz = closure★.convective_κz,\n      background_κz = closure★.background_κz)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Visualizing-the-priors","page":"Intro to InverseProblem","title":"Visualizing the priors","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"We visualize our prior distributions by plotting a huge number of samples:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"using OceanTurbulenceParameterEstimation.EnsembleKalmanInversions: convert_prior, inverse_parameter_transform\n\nNsamples = 50000000\n\nsamples(prior) = [inverse_parameter_transform(prior, θ) for θ in rand(convert_prior(prior), Nsamples)]\n\nconvective_κz_samples = samples(priors.convective_κz)\nbackground_κz_samples = samples(priors.background_κz)\n\nfig = Figure()\nax_top = Axis(fig[1, 1], xlabel = \"convective κᶻ [m² s⁻¹]\", ylabel = \"Density\")\ndensity!(ax_top, convective_κz_samples)\nxlims!(ax_top, 0, 10)\n\nax_bottom = Axis(fig[2, 1], xlabel = \"background κᶻ [m² s⁻¹]\", ylabel = \"Density\")\ndensity!(ax_bottom, background_κz_samples)\n\nsave(\"prior_visualization.svg\", fig)\nnothing # hide","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"(Image: )","category":"page"},{"location":"literated/intro_to_inverse_problems/#The-InverseProblem","page":"Intro to InverseProblem","title":"The InverseProblem","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"We can construct the inverse problem y = G(θ) + η. Here, y are the observations and G is the ensemble_model.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Using-InverseProblem-to-compute-forward_map","page":"Intro to InverseProblem","title":"Using InverseProblem to compute forward_map","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"As a sanity check we apply the forward_map on the calibration after we initialize all ensemble members with the true parameter values. We then confirm that the output of the forward_map matches the observations to machine precision.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"θ¹ = (convective_κz = 0.8 * θ★.convective_κz,\n      background_κz = 9.0 * θ★.background_κz)\n\nθ² = (convective_κz = 2.0 * θ★.convective_κz,\n      background_κz = 0.1 * θ★.background_κz)\n\nθ_ensemble = [θ★, θ¹, θ²]\n\nG = forward_map(calibration, θ_ensemble)\ny = observation_map(calibration)","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"The forward_map output G is a two-dimensional matrix whose first dimension is the size of the state space and whose second dimension is the ensemble_size. Here we ensure that mapped output first ensemble member, which was run with the \"true\" parameters, is identical to the mapped observations:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"G[:, 1] ≈ y","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"Visualizing forward model output","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"Next we visualize the discrepency between solutions generated by true and non-optimal parameter sets θ¹ and θ². Time-series data from the ensemble run is collected by calibration.time_series_collector:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"time_series_collector = calibration.time_series_collector\ntimes = time_series_collector.times\n\n# Extract last save point and plot each solution component\nNt = length(times)\n\nb = time_series_collector.field_time_serieses.b[Nt]\nt = times[Nt]\nz = znodes(b)\n\n# The ensemble varies along the first, or `x`-dimension:\nb★ = interior(b)[1, 1, :]\nb¹ = interior(b)[2, 1, :]\nb² = interior(b)[3, 1, :]\n\nfig = Figure()\nax = Axis(fig[1, 1],\n          xlabel = \"Buoyancy [m s⁻²]\",\n          ylabel = \"Depth [m]\")\n\nb★_label = \"true b at t = \" * prettytime(t)\nb¹_label = \"b with $θ¹\"\nb²_label = \"b with $θ²\"\n\nlines!(ax, b★, z; label=b★_label, linewidth=2)\nlines!(ax, b¹, z; label=b¹_label, linewidth=2)\nlines!(ax, b², z; label=b²_label, linewidth=2)\n\naxislegend(ax, position=:lt)\n\nsave(\"ensemble_simulation_demonstration.svg\", fig)\nnothing # hide","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"(Image: )","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation Instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"You can install the latest version of OceanTurbulenceParameterEstimation.jl via the built-in package manager (by pressing ] in the Julia REPL command prompt) to add the package and also to  instantiate/build all the required dependencies","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"julia>]\n(v1.6) pkg> add https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl\n(v1.6) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"We recommend installing OceanTurbulenceParameterEstimation.jl with the built-in Julia package manager, because this installs a stable, tagged release. You can update OceanTurbulenceParameterEstimation.jl again via the package manager by typing","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"(v1.6) pkg> update OceanTurbulenceParameterEstimation","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/internals/#Private-types-and-functions","page":"Private","title":"Private types and functions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Documentation for OceanTurbulenceParameterEstimation.jl's internal interface.","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation","page":"Private","title":"OceanTurbulenceParameterEstimation","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation]\nPublic = false\nPages   = [\"OceanTurbulenceParameterEstimation.jl\"]","category":"page"},{"location":"library/internals/#Observations","page":"Private","title":"Observations","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.Observations]\nPublic = false\nPages   = [\"Observations.jl\"]","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.FieldTimeSeriesCollector-Tuple{Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.FieldTimeSeriesCollector","text":"FieldTimeSeriesCollector(fields)\n\nReturns a FieldTimeSeriesCollector for fields of simulation.\n\nfields is a NamedTuple of AbstractFields that are to be collected.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.OneDimensionalTimeSeries","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.OneDimensionalTimeSeries","text":"OneDimensionalTimeSeries{F, G, T, P, M} <: AbstractObservation\n\nA time series of horizontally-averaged observational or LES data gridded as Oceananigans fields.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.column_ensemble_interior-Tuple{Vector{var\"#s35\"} where var\"#s35\"<:OneDimensionalTimeSeries, Any, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.column_ensemble_interior","text":"column_ensemble_interior(observations::Vector{<:OneDimensionalTimeSeries}, field_name, time_indices::Vector, N_ens)\n\nReturns an N_cases × N_ens × Nz array of the interior of a field field_name defined on a  OneDimensionalEnsembleGrid of size N_cases × N_ens × Nz, given a list of OneDimensionalTimeSeries objects containing the N_cases single-column fields at time index in time_index.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.observation_names-Tuple{Vector{var\"#s28\"} where var\"#s28\"<:OneDimensionalTimeSeries}","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.observation_names","text":"observation_names(ts_vector::Vector{<:OneDimensionalTimeSeries})\n\nReturn a Set representing the union of all names in ts_vector.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#TurbulenceClosureParameters","page":"Private","title":"TurbulenceClosureParameters","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.TurbulenceClosureParameters]\nPublic = false\nPages   = [\"TurbulenceClosureParameters.jl\"]","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.FreeParameters-Tuple{Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.FreeParameters","text":"FreeParameters(priors; names = Symbol.(keys(priors)))\n\nReturn named FreeParameters with priors. Free parameter names are inferred from the keys of priors if not provided.\n\nExample\n\njulia> using Distributions, OceanTurbulenceParameterEstimation\n\njulia> priors = (ν = Normal(1e-4, 1e-5), κ = Normal(1e-3, 1e-5))\n(ν = Normal{Float64}(μ=0.0001, σ=1.0e-5), κ = Normal{Float64}(μ=0.001, σ=1.0e-5))\n\njulia> free_parameters = FreeParameters(priors)\nFreeParameters with 2 parameters\n├── names: (:ν, :κ)\n└── priors: Dict{Symbol, Any}\n    ├── ν => Normal{Float64}(μ=0.0001, σ=1.0e-5)\n    └── κ => Normal{Float64}(μ=0.001, σ=1.0e-5)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.closure_with_parameters-Tuple{Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.closure_with_parameters","text":"closure_with_parameters(closure, parameters)\n\nReturns a new object where for each (parameter_name, parameter_value) pair  in parameters, the value corresponding to the key in object that matches parameter_name is replaced with parameter_value.\n\nExample\n\njulia> using OceanTurbulenceParameterEstimation\n\njulia> struct ClosureSubModel; a; b end\n\njulia> struct Closure; test; c end\n\njulia> closure = Closure(ClosureSubModel(1, 2), 3)\nClosure(ClosureSubModel(1, 2), 3)\n\njulia> parameters = (a = 12, d = 7)\n(a = 12, d = 7)\n\njulia> OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.closure_with_parameters(closure, parameters)\nClosure(ClosureSubModel(12, 2), 3)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#EnsembleKalmanInversions","page":"Private","title":"EnsembleKalmanInversions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.EnsembleKalmanInversions]\nPublic = false\nPages   = [\"EnsembleKalmanInversions.jl\"]","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.EnsembleKalmanInversion-Tuple{Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.EnsembleKalmanInversion","text":"EnsembleKalmanInversion(inverse_problem; noise_covariance=1e-2)\n\nReturn an object that interfaces with EnsembleKalmanProcesses.jl and uses Ensemble Kalman Inversion to iteratively \"solve\" the inverse problem:\n\ny = G(θ) + η\n\nfor the parameters θ, where y is a \"normalized\" vector of observations, G(θ) is a forward map that predicts the observations, and η  N(0 Γ_y) is zero-mean random noise with covariance matrix Γ_y representing uncertainty in the observations.\n\nBy \"solve\", we mean that the iteration finds the parameter values θ that minimizes the distance between y and G(θ).\n\nThe \"forward map output\" G can have many interpretations. The specific statistics that G computes have to be selected for each use case to provide a concise summary of the complex model solution that contains the values that we would most like to match to the corresponding truth values y. For example, in the context of an ocean-surface boundary layer parametrization, this summary could be a vector of  concatenated u, v, b, e profiles at all or some time steps of the CATKE solution.\n\n(For more details on the Ensemble Kalman Inversion algorithm refer to the EnsembleKalmanProcesses.jl Documentation.)\n\nArguments\n\ninverse_problem :: InverseProblem: Represents an inverse problem representing the comparison between                                      synthetic observations generated by Oceananigans.jl                                      and model predictions, also generated by Oceananigans.jl.\nnoise_covariance (AbstractMatrix or Number): normalized covariance representing observational                                                    uncertainty. If noise_covariance isa Number then                                                    it's converted to an identity matrix scaled by                                                    noise_covariance.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.UnscentedKalmanInversion-Tuple{Any, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.UnscentedKalmanInversion","text":"UnscentedKalmanInversion(inverse_problem, prior_mean, prior_cov;\n                         noise_covariance = 1e-2, α_reg = 1, update_freq = 0)\n\nReturn an object that interfaces with EnsembleKalmanProcesses.jl and uses Unscented Kalman Inversion to iteratively \"solve\" the inverse problem:\n\ny = G(θ) + η\n\nfor the parameters θ, where y is a \"normalized\" vector of observations, G(θ) is a forward map that predicts the observations, and η  N(0 Γ_y) is zero-mean random noise with covariance matrix Γ_y representing uncertainty in the observations.\n\nBy \"solve\", we mean that the iteration finds the parameter values θ that minimizes the distance between y and G(θ).\n\n(For more details on the Unscented Kalman Inversion algorithm refer to the EnsembleKalmanProcesses.jl Documentation.)\n\nArguments\n\ninverse_problem :: InverseProblem: an inverse problem representing the comparison between                                       synthetic observations generated by Oceananigans.jl                                      and model predictions also generated by Oceananigans.jl.\nprior_mean :: Vector{Float64}: prior mean\nprior_cov :: Matrix{Float64}: prior covariance\nnoise_covariance :: Float64: observation error covariance\nα_reg :: Float64: regularization parameter toward the prior mean (0 < α_reg ≤ 1);                     default α_reg=1 implies no regularization\nupdate_freq :: IT: set to 0 when the inverse problem is not identifiable (default), namely the                      inverse problem has multiple solutions, the covariance matrix will represent                      only the sensitivity of the parameters, instead of posterior covariance information;                      set to 1 (or anything > 0) when the inverse problem is identifiable, and                       the covariance matrix will converge to a good approximation of the                       posterior covariance with an uninformative prior\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.UnscentedKalmanInversionPostprocess-Tuple{Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.UnscentedKalmanInversionPostprocess","text":"UnscentedKalmanInversionPostprocess(eki)\n\nReturns\n\nmean :: Matrix{Float64}: N_iterations × N_parameters mean matrix\ncov :: Vector{Matrix{Float64}}: N_iterations vector of N_parameters × N_parameters covariance matrix\nstd :: Matrix{Float64}: N_iterations × N_parameters standard deviation matrix\nerr :: Vector{Float64}: N_iterations error array\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.iterate!-Tuple{EnsembleKalmanInversion}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.iterate!","text":"iterate!(eki::EnsembleKalmanInversion; iterations=1)\n\nIterate the ensemble Kalman inversion problem eki forward by iterations.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.sample-NTuple{4, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.sample","text":"sample(eki, θ, G, n)\n\nGenerate n new particles sampled from a multivariate Normal distribution parameterized  by the ensemble mean and covariance computed based on the N_θ × N_ensemble ensemble  array θ, under the condition that all n particles lead to forward map outputs that are \"stable\" (don't include NaNs). G is the inverting forward map computed on ensemble θ.\n\nReturn an N_θ × n array of new particles, along with the inverting forward  map output corresponding to the new particles.\n\n\n\n\n\n","category":"method"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/master/examples/perfect_baroclinic_adjustment_calibration.jl\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Perfect-baroclinic-adjustment-calibration-with-Ensemble-Kalman-Inversion","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"This example showcases a \"perfect model calibration\" of the two-dimensional baroclinic adjustement problem (depth-latitude) with eddies parametrized using Gent-McWilliams–Redi isoneutral diffusion closure. We use output for buoyancy (b) and a passive-tracer concentration (c) to calibrate the parametrization.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Install-dependencies","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using Pkg\npkg\"add Oceananigans, Distributions, CairoMakie, OceanTurbulenceParameterEstimation\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First we load few things","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using OceanTurbulenceParameterEstimation\nusing Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.TurbulenceClosures: FluxTapering\nusing Oceananigans.Models.HydrostaticFreeSurfaceModels: SliceEnsembleSize\nusing Distributions\nusing Printf\nusing LinearAlgebra: norm","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Set-up-the-problem-and-generate-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Set up the problem and generate observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Define the  \"true\" skew and symmetric diffusivity coefficients. These are the parameter values that we use to generate the data. Then, we'll see if the EKI calibration can recover these values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"κ_skew = 1000.0       # [m² s⁻¹] skew diffusivity\nκ_symmetric = 900.0   # [m² s⁻¹] symmetric diffusivity\nnothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We gather the \"true\" parameters in a named tuple θ_*:","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"θ★ = (κ_skew = κ_skew, κ_symmetric = κ_symmetric)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The experiment name and where the synthetic observations will be saved.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"experiment_name = \"baroclinic_adjustment\"\ndata_path = experiment_name * \".jld2\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The domain, number of grid points, and other parameters.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"architecture = CPU()      # CPU or GPU?\n\nLy = 1000kilometers       # north-south extent [m]\nLz = 1kilometers          # depth [m]\n\nNy = 64                   # grid points in north-south direction\nNz = 16                   # grid points in the vertical\n\nΔt = 10minute             # time-step\n\nstop_time = 1days         # length of run\nsave_interval = 0.25days  # save observation every so often\n\ngenerate_observations = true\nnothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The isopycnal skew-symmetric diffusivity closure.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"gerdes_koberle_willebrand_tapering = FluxTapering(1e-2)\ngent_mcwilliams_diffusivity = IsopycnalSkewSymmetricDiffusivity(κ_skew = κ_skew,\n                                                                κ_symmetric = κ_symmetric,\n                                                                slope_limiter = gerdes_koberle_willebrand_tapering)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Generate-synthetic-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Generate synthetic observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"if generate_observations || !(isfile(data_path))\n    grid = RectilinearGrid(topology = (Flat, Bounded, Bounded),\n                           size = (Ny, Nz),\n                           y = (-Ly/2, Ly/2),\n                           z = (-Lz, 0),\n                           halo = (3, 3))\n\n    model = HydrostaticFreeSurfaceModel(architecture = architecture,\n                                        grid = grid,\n                                        tracers = (:b, :c),\n                                        buoyancy = BuoyancyTracer(),\n                                        coriolis = BetaPlane(latitude=-45),\n                                        closure = gent_mcwilliams_diffusivity,\n                                        free_surface = ImplicitFreeSurface())\n\n    @info \"Built $model.\"\n\n    ##### Initial conditions of an unstable buoyancy front\n\n    \"\"\"\n    Linear ramp from 0 to 1 between -Δy/2 and +Δy/2.\n\n    For example:\n\n    y < y₀           => ramp = 0\n    y₀ < y < y₀ + Δy => ramp = y / Δy\n    y > y₀ + Δy      => ramp = 1\n    \"\"\"\n    ramp(y, Δy) = min(max(0, y/Δy + 1/2), 1)\n\n    N² = 4e-6             # [s⁻²] buoyancy frequency / stratification\n    M² = 8e-8             # [s⁻²] horizontal buoyancy gradient\n\n    Δy = 50kilometers     # horizontal extent of the font\n\n    Δc_y = 2Δy            # horizontal extent of initial tracer concentration\n    Δc_z = 50             # [m] vertical extent of initial tracer concentration\n\n    Δb = Δy * M²          # inital buoyancy jump\n\n    bᵢ(x, y, z) = N² * z + Δb * ramp(y, Δy)\n    cᵢ(x, y, z) = exp(-y^2 / 2Δc_y^2) * exp(-(z + Lz/2)^2 / (2Δc_z^2))\n\n    set!(model, b=bᵢ, c=cᵢ)\n\n    simulation = Simulation(model, Δt=Δt, stop_time=stop_time)\n\n    simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),\n                                                          schedule = TimeInterval(save_interval),\n                                                          prefix = experiment_name,\n                                                          array_type = Array{Float64},\n                                                          field_slicer = nothing,\n                                                          force = true)\n\n    run!(simulation)\nend","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Load-truth-data-as-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Load truth data as observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"observations = OneDimensionalTimeSeries(data_path, field_names=(:b, :c), normalize=ZScore)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Calibration-with-Ensemble-Kalman-Inversion","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Ensemble-model","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Ensemble model","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First we set up an ensemble model,","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_size = 20\n\nslice_ensemble_size = SliceEnsembleSize(size=(Ny, Nz), ensemble=ensemble_size)\n@show ensemble_grid = RectilinearGrid(size=slice_ensemble_size,\n                                             topology = (Flat, Bounded, Bounded),\n                                             y = (-Ly/2, Ly/2),\n                                             z = (-Lz, 0),\n                                             halo=(3, 3))\n\nclosure_ensemble = [deepcopy(gent_mcwilliams_diffusivity) for i = 1:ensemble_size]\n\n@show ensemble_model = HydrostaticFreeSurfaceModel(architecture = architecture,\n                                                   grid = ensemble_grid,\n                                                   tracers = (:b, :c),\n                                                   buoyancy = BuoyancyTracer(),\n                                                   coriolis = BetaPlane(latitude=-45),\n                                                   closure = closure_ensemble,\n                                                   free_surface = ImplicitFreeSurface())","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"and then we create an ensemble simulation:","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_simulation = Simulation(ensemble_model; Δt, stop_time)\n\nensemble_simulation","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Free-parameters","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Free parameters","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We construct some prior distributions for our free parameters. We found that it often helps to constrain the prior distributions so that neither very high nor very low values for diffusivities can be drawn out of the distribution.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"priors = (\n    κ_skew = ConstrainedNormal(0.0, 1.0, 400.0, 1300.0),\n    κ_symmetric = ConstrainedNormal(0.0, 1.0, 700.0, 1700.0)\n)\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"To visualize the prior distributions we randomly sample out values from then and plot the p.d.f.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using CairoMakie\nusing OceanTurbulenceParameterEstimation.EnsembleKalmanInversions: convert_prior, inverse_parameter_transform\n\nsamples(prior) = [inverse_parameter_transform(prior, x) for x in rand(convert_prior(prior), 10000000)]\n\nsamples_κ_skew = samples(priors.κ_skew)\nsamples_κ_symmetric = samples(priors.κ_symmetric)\n\nf = Figure()\naxtop = Axis(f[1, 1],\n             xlabel = \"diffusivities [m² s⁻¹]\",\n             ylabel = \"p.d.f.\")\ndensities = []\npush!(densities, density!(axtop, samples_κ_skew))\npush!(densities, density!(axtop, samples_κ_symmetric))\nLegend(f[1, 2], densities, [\"κ_skew\", \"κ_symmetric\"], position = :lb)\n\nsave(\"visualize_prior_diffusivities_baroclinic_adjustment.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#The-inverse-problem","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"The inverse problem","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We can construct the inverse problem y = G(θ) + η. Here, y are the observations and G is the ensemble_model.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Assert-that-G(θ_*)-y","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Assert that G(θ_*)  y","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"As a sanity check we apply the forward_map on the calibration after we initialize all ensemble members with the true parameter values. We then confirm that the output of the forward_map matches the observations to machine precision.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"G = forward_map(calibration, [θ★])\ny = observation_map(calibration)\nnothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The forward_map output x is a two-dimensional matrix whose first dimension is the size of the state space (here, 2 N_y N_z; the 2 comes from the two tracers we used as observations) and whose second dimension is the ensemble_size. In the case above, all columns of x are identical.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"mean(G, dims=2) ≈ y","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Next, we construct an EnsembleKalmanInversion (EKI) object,","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"eki = EnsembleKalmanInversion(calibration; noise_covariance = 1e-2)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"params = iterate!(eki; iterations = 5)\n\n@show params","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Last, we visualize few metrics regarding how the EKI calibration went about.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"θ̅(iteration) = [eki.iteration_summaries[iteration].ensemble_mean...]\nvarθ(iteration) = eki.iteration_summaries[iteration].ensemble_var\n\nweight_distances = [norm(θ̅(iter) - [θ★[1], θ★[2]]) for iter in 1:eki.iteration]\noutput_distances = [norm(forward_map(calibration, θ̅(iter))[:, 1] - y) for iter in 1:eki.iteration]\nensemble_variances = [varθ(iter) for iter in 1:eki.iteration]\n\nf = Figure()\nlines(f[1, 1], 1:eki.iteration, weight_distances, color = :red, linewidth = 2,\n      axis = (title = \"Parameter distance\",\n              xlabel = \"Iteration\",\n              ylabel=\"|θ̅ₙ - θ⋆|\",\n              yscale = log10))\nlines(f[1, 2], 1:eki.iteration, output_distances, color = :blue, linewidth = 2,\n      axis = (title = \"Output distance\",\n              xlabel = \"Iteration\",\n              ylabel=\"|G(θ̅ₙ) - y|\",\n              yscale = log10))\nax3 = Axis(f[2, 1:2], title = \"Parameter convergence\",\n           xlabel = \"Iteration\",\n           ylabel = \"Ensemble variance\",\n           yscale = log10)\n\nfor (i, pname) in enumerate(free_parameters.names)\n    ev = getindex.(ensemble_variances, i)\n    lines!(ax3, 1:eki.iteration, ev / ev[1], label = String(pname), linewidth = 2)\nend\n\naxislegend(ax3, position = :rt)\nsave(\"summary_baroclinic_adjustment.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"f = Figure()\n\naxtop = Axis(f[1, 1])\n\naxmain = Axis(f[2, 1],\n              xlabel = \"κ_skew [m² s⁻¹]\",\n              ylabel = \"κ_symmetric [m² s⁻¹]\")\n\naxright = Axis(f[2, 2])\nscatters = []\n\nfor iteration in [1, 2, 3, 6]\n    # Make parameter matrix\n    parameters = eki.iteration_summaries[iteration].parameters\n    Nensemble = length(parameters)\n    Nparameters = length(first(parameters))\n    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:Nparameters]\n\n    push!(scatters, scatter!(axmain, parameter_ensemble_matrix))\n    density!(axtop, parameter_ensemble_matrix[:, 1])\n    density!(axright, parameter_ensemble_matrix[:, 2], direction = :y)\nend\n\nvlines!(axmain, [κ_skew], color = :red)\nvlines!(axtop, [κ_skew], color = :red)\n\nhlines!(axmain, [κ_symmetric], color = :red)\nhlines!(axright, [κ_symmetric], color = :red)\n\ncolsize!(f.layout, 1, Fixed(300))\ncolsize!(f.layout, 2, Fixed(200))\n\nrowsize!(f.layout, 1, Fixed(200))\nrowsize!(f.layout, 2, Fixed(300))\n\nLegend(f[1, 2], scatters,\n       [\"Initial ensemble\", \"Iteration 1\", \"Iteration 2\", \"Iteration 5\"],\n       position = :lb)\n\nhidedecorations!(axtop, grid = false)\nhidedecorations!(axright, grid = false)\n\nxlims!(axmain, 350, 1350)\nxlims!(axtop, 350, 1350)\nylims!(axmain, 650, 1750)\nylims!(axright, 650, 1750)\nxlims!(axright, 0, 0.025)\nylims!(axtop, 0, 0.025)\n\nsave(\"distributions_baroclinic_adjustment.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/master/examples/intro_to_observations.jl\"","category":"page"},{"location":"literated/intro_to_observations/#Intro-to-observations","page":"Intro to observations","title":"Intro to observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"This example demonstrates the features of OneDimensionalTimeSeries when constructed from  \"synthetic observations\" generated by an Oceananigans Simulation.","category":"page"},{"location":"literated/intro_to_observations/#Install-dependencies","page":"Intro to observations","title":"Install dependencies","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"First we load few things","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"using OceanTurbulenceParameterEstimation\nusing Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.TurbulenceClosures: ConvectiveAdjustmentVerticalDiffusivity\nusing CairoMakie","category":"page"},{"location":"literated/intro_to_observations/#Generating-synthetic-observations","page":"Intro to observations","title":"Generating synthetic observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"We define a utility function for constructing synthetic observations,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"default_closure = ConvectiveAdjustmentVerticalDiffusivity(; convective_κz = 1.0,\n                                                            convective_νz = 0.9,\n                                                            background_κz = 1e-4,\n                                                            background_νz = 1e-5)\n\nfunction generate_synthetic_observations(name = \"convective_adjustment\"; Nz = 32, Lz = 64,\n                                         Qᵇ = +1e-8, Qᵘ = -1e-5, f₀ = 1e-4, N² = 1e-6,\n                                         Δt = 10.0, stop_time = 12hours,\n                                         tracers = :b, closure = default_closure)\n\n    data_path = name * \".jld2\"\n    isfile(data_path) && return data_path\n\n    grid = RectilinearGrid(size=Nz, z=(-Lz, 0), topology=(Flat, Flat, Bounded))\n    u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ))\n    b_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵇ), bottom = GradientBoundaryCondition(N²))\n\n    model = HydrostaticFreeSurfaceModel(; grid, tracers, closure,\n                                          buoyancy = BuoyancyTracer(),\n                                          boundary_conditions = (; u=u_bcs, b=b_bcs),\n                                          coriolis = FPlane(f=f₀))\n\n    set!(model, b = (x, y, z) -> N² * z)\n    simulation = Simulation(model; Δt, stop_time)\n    init_with_parameters(file, model) = file[\"parameters\"] = (; Qᵇ, Qᵘ, Δt, N², tracers=(:b, :e))\n\n    simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),\n                                                          schedule = TimeInterval(stop_time/3),\n                                                          prefix = name,\n                                                          array_type = Array{Float64},\n                                                          field_slicer = nothing,\n                                                          init = init_with_parameters,\n                                                          force = true)\n\n    run!(simulation)\n\n    return data_path\nend","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"and invoke it:","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"data_path = generate_synthetic_observations()","category":"page"},{"location":"literated/intro_to_observations/#Specifying-observations","page":"Intro to observations","title":"Specifying observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"When synthetic observations are constructed from simulation data, we can select","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"The fields to include via field_names\nWhich data in the time-series to include via the times keyword. This can be used to change the initial condition for a calibration run.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"For example, to build observations with a single field we write,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"single_field_observations = OneDimensionalTimeSeries(data_path, field_names=:b, normalize=ZScore)","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"To build observations with two fields we write","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"two_field_observations = OneDimensionalTimeSeries(data_path, field_names=(:u, :b), normalize=ZScore)","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"And to build observations with specified times we write","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"times = single_field_observations.times[2:end]\nspecified_times_observations = OneDimensionalTimeSeries(data_path, field_names=(:u, :b), normalize=ZScore, times=times)","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"Notice that in the last case, specified_times_observations.times is missing 0.0.","category":"page"},{"location":"literated/intro_to_observations/#Visualizing-observations","page":"Intro to observations","title":"Visualizing observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"For this we include the initial condition and v velocity component,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"observations = OneDimensionalTimeSeries(data_path, field_names=(:u, :v, :b), normalize=ZScore)\n\nfig = Figure()\n\nax_b = Axis(fig[1, 1], xlabel = \"Buoyancy [10⁻⁴ m s⁻²]\", ylabel = \"Depth [m]\")\nax_u = Axis(fig[1, 2], xlabel = \"Velocities [m s⁻¹]\", ylabel = \"Depth [m]\")\n\nz = znodes(Center, observations.grid)\n\ncolorcycle = [:black, :red, :blue, :orange, :pink]\n\nfor i = 1:length(observations.times)\n    b = observations.field_time_serieses.b[i]\n    u = observations.field_time_serieses.u[i]\n    v = observations.field_time_serieses.v[i]\n    t = observations.times[i]\n\n    label = \"t = \" * prettytime(t)\n    u_label = i == 1 ? \"u, \" * label : label\n    v_label = i == 1 ? \"v, \" * label : label\n\n    lines!(ax_b, 1e4 * interior(b)[1, 1, :], z; label, color=colorcycle[i]) # convert units from m s⁻² to 10⁻⁴ m s⁻²\n    lines!(ax_u, interior(u)[1, 1, :], z; linestyle=:solid, color=colorcycle[i], label=u_label)\n    lines!(ax_u, interior(v)[1, 1, :], z; linestyle=:dash, color=colorcycle[i], label=v_label)\nend\n\naxislegend(ax_b, position=:rb)\naxislegend(ax_u, position=:lb, merge=true)\n\nsave(\"intro_to_observations.svg\", fig)","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"(Image: )","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"Hint: if using a REPL or notebook, try using Pkg; Pkg.add(\"ElectronDisplay\"); using ElectronDisplay; display(fig) To see the figure in a window.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#OceanTurbulenceParameterEstimation.jl-Documentation","page":"Home","title":"OceanTurbulenceParameterEstimation.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OceanTurbulenceParameterEstimation provides a framework to calibrate turbulence closure parametrizations for ocean models.","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for OceanTurbulenceParameterEstimation.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"library/public/#OceanTurbulenceParameterEstimation","page":"Public","title":"OceanTurbulenceParameterEstimation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation]\nPrivate = false\nPages   = [\"OceanTurbulenceParameterEstimation.jl\"]","category":"page"},{"location":"library/public/#Observations","page":"Public","title":"Observations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.Observations]\nPrivate = false\nPages   = [\"Observations.jl\"]","category":"page"},{"location":"library/public/#TurbulenceClosureParameters","page":"Public","title":"TurbulenceClosureParameters","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.TurbulenceClosureParameters]\nPrivate = false\nPages   = [\"TurbulenceClosureParameters.jl\"]","category":"page"},{"location":"library/public/#EnsembleKalmanInversions","page":"Public","title":"EnsembleKalmanInversions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.EnsembleKalmanInversions]\nPrivate = false\nPages   = [\"EnsembleKalmanInversions.jl\"]","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/master/examples/perfect_convective_adjustment_calibration.jl\"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Perfect-convective-adjustment-calibration-with-Ensemble-Kalman-Inversion","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"This example calibrates a convective adjustment model in the \"perfect model context\". In this context, synthetic observations are generated by a convective adjustment model with \"true\" parameters. The true parameters are then \"rediscovered\" by calibrating the model to match the synthetic observations.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"We use the discrepency between observed and modeled buoyancy b to calibrate the convective adjustment model. The calibration problem is solved by Ensemble Kalman Inversion. For more information about Ensemble Kalman Inversion, see the EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Install-dependencies","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"using OceanTurbulenceParameterEstimation, LinearAlgebra, CairoMakie","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"We reuse some some code from a previous example to generate observations,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"examples_path = joinpath(pathof(OceanTurbulenceParameterEstimation), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_inverse_problems.jl\"))\n\ndata_path = generate_synthetic_observations()\nobservations = OneDimensionalTimeSeries(data_path, field_names=:b, normalize=ZScore)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"and an ensemble_simulation,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_simulation, closure★ = build_ensemble_simulation(observations; Nensemble=50)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The handy utility function build_ensemble_simulation also tells us the optimal parameters that were used when generating the synthetic observations:","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"@show θ★ = (convective_κz = closure★.convective_κz, background_κz = closure★.background_κz)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#The-InverseProblem","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"The InverseProblem","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"To build an inverse problem we first define free parameters. Here we calibrate convective_κz and background_κz, using log-normal priors to prevent the parameters from becoming negative:","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"priors = (convective_κz = lognormal_with_mean_std(0.3, 0.5),\n          background_κz = lognormal_with_mean_std(2.5e-4, 2.5e-5))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The InverseProblem is then constructed from observations, ensemble_simulation, and free_parameters,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"For more information about the above steps, see Intro to observations and Intro to InverseProblem.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Ensemble-Kalman-Inversion","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"Next, we construct an EnsembleKalmanInversion (EKI) object,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The calibration is done here using Ensemble Kalman Inversion. For more information about the algorithm refer to EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"noise_variance = observation_map_variance_across_time(calibration)[1, :, 1] .+ 1e-5\n\neki = EnsembleKalmanInversion(calibration; noise_covariance = Matrix(Diagonal(noise_variance)))","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"iterate!(eki; iterations = 10)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"Last, we visualize the outputs of EKI calibration.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"θ̅(iteration) = [eki.iteration_summaries[iteration].ensemble_mean...]\nvarθ(iteration) = eki.iteration_summaries[iteration].ensemble_var\n\nweight_distances = [norm(θ̅(iter) - [θ★[1], θ★[2]]) for iter in 1:eki.iteration]\noutput_distances = [norm(forward_map(calibration, θ̅(iter))[:, 1] - y) for iter in 1:eki.iteration]\nensemble_variances = [varθ(iter) for iter in 1:eki.iteration]\n\nf = Figure()\n\nlines(f[1, 1], 1:eki.iteration, weight_distances, color = :red, linewidth = 2,\n      axis = (title = \"Parameter distance\",\n              xlabel = \"Iteration\",\n              ylabel = \"|θ̅ₙ - θ★|\"))\n\nlines(f[1, 2], 1:eki.iteration, output_distances, color = :blue, linewidth = 2,\n      axis = (title = \"Output distance\",\n              xlabel = \"Iteration\",\n              ylabel = \"|G(θ̅ₙ) - y|\"))\n\nax3 = Axis(f[2, 1:2],\n           title = \"Parameter convergence\",\n           xlabel = \"Iteration\",\n           ylabel = \"Ensemble variance\",\n           yscale = log10)\n\nfor (i, pname) in enumerate(free_parameters.names)\n    ev = getindex.(ensemble_variances, i)\n    lines!(ax3, 1:eki.iteration, ev / ev[1], label = String(pname), linewidth = 2)\nend\n\naxislegend(ax3, position = :rt)\n\nsave(\"summary_convective_adjustment_eki.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"f = Figure()\n\naxtop = Axis(f[1, 1])\n\naxmain = Axis(f[2, 1],\n              xlabel = \"convective_κz [m² s⁻¹]\",\n              ylabel = \"background_κz [m² s⁻¹]\")\n\naxright = Axis(f[2, 2])\nscatters = []\n\nfor iteration in [1, 2, 3, 11]\n    # Make parameter matrix\n    parameters = eki.iteration_summaries[iteration].parameters\n    Nensemble = length(parameters)\n    Nparameters = length(first(parameters))\n    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:Nparameters]\n\n    push!(scatters, scatter!(axmain, parameter_ensemble_matrix))\n    density!(axtop, parameter_ensemble_matrix[:, 1])\n    density!(axright, parameter_ensemble_matrix[:, 2], direction = :y)\nend\n\nvlines!(axmain, [θ★.convective_κz], color = :red)\nvlines!(axtop, [θ★.convective_κz], color = :red)\n\nhlines!(axmain, [θ★.background_κz], color = :red)\nhlines!(axright, [θ★.background_κz], color = :red)\n\ncolsize!(f.layout, 1, Fixed(300))\ncolsize!(f.layout, 2, Fixed(200))\nrowsize!(f.layout, 1, Fixed(200))\nrowsize!(f.layout, 2, Fixed(300))\n\nLegend(f[1, 2], scatters, [\"Initial ensemble\", \"Iteration 1\", \"Iteration 2\", \"Iteration 10\"],\n       position = :lb)\n\nhidedecorations!(axtop, grid = false)\nhidedecorations!(axright, grid = false)\n\nxlims!(axmain, -0.25, 3.2)\nxlims!(axtop, -0.25, 3.2)\nylims!(axmain, 5e-5, 35e-5)\nylims!(axright, 5e-5, 35e-5)\n\nsave(\"distributions_convective_adjustment_eki.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"}]
}
