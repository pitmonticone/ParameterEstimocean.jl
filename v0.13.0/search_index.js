var documenterSearchIndex = {"docs":
[{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"EditURL = \"https://github.com/CliMA/ParameterEstimocean.jl/blob/main/examples/multi_case_lesbrary_ri_based_calibration.jl\"","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/#Calibration-of-RiBasedVerticalDiffusivity-to-five-LESbrary-simulations","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"","category":"section"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/#Install-dependencies","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Install dependencies","text":"","category":"section"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"using Pkg\npkg\"add ParameterEstimocean, Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"using Oceananigans\nusing Oceananigans.Units\nusing ParameterEstimocean\nusing LinearAlgebra, CairoMakie, DataDeps, Distributions\n\nusing Oceananigans.TurbulenceClosures: RiBasedVerticalDiffusivity","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/#Using-LESbrary-data","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Using LESbrary data","text":"","category":"section"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"ParameterEstimocean.jl provides paths to synthetic observations derived from high-fidelity large eddy simulations. In this example, we illustrate calibration of a turbulence parameterization to one of these simulations:","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"cases = [\"free_convection\",\n         \"strong_wind_weak_cooling\",\n         \"weak_wind_strong_cooling\",\n         \"strong_wind\",\n         \"strong_wind_no_rotation\"]\n\ndatapaths = [@datadep_str(\"two_day_suite_1m/$(case)_instantaneous_statistics.jld2\") for case in cases]\n\ntimes = [2hours, 12hours, 24hours]\nfield_names = (:b, :u, :v)\ntransformation = ZScore()\nregrid = (1, 1, 32)\n\nobservations = [SyntheticObservations(path; field_names, times, transformation, regrid)\n                for path in datapaths]","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"Let's take a look at the observations. We define a few plotting utilities along the way to use later in the example:","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"colorcycle = [:black, :red, :darkblue, :orange, :pink1, :seagreen, :magenta2]\nmarkercycle = [:rect, :utriangle, :star5, :circle, :cross, :+, :pentagon]\n\nfunction make_figure_axes(n=1)\n    fig = Figure(resolution=(1200, n*400))\n    axs = []\n    for i = 1:n\n        ax_b = Axis(fig[i, 1], xlabel = \"Buoyancy \\n[cm s⁻²]\", ylabel = \"z [m]\")\n        ax_u = Axis(fig[i, 2], xlabel = \"x-velocity, u \\n[cm s⁻¹]\")\n        ax_v = Axis(fig[i, 3], xlabel = \"y-velocity, v \\n[cm s⁻¹]\")\n        push!(axs, (ax_b, ax_u, ax_v))\n    end\n    n == 1 && (axs = first(axs))\n    return fig, axs\nend\n\nfunction plot_fields!(axs, b, u, v, label, color, grid=first(observations).grid)\n    z = znodes(Center, grid)\n    # Note unit conversions below, eg m s⁻² -> cm s⁻²:\n    lines!(axs[1], 1e2 * b, z; color, label)\n    lines!(axs[2], 1e2 * u, z; color, label)\n    lines!(axs[3], 1e2 * v, z; color, label)\n    return nothing\nend","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"And then plot the evolution of the observed fields,","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"fig, axs = make_figure_axes()\n\nfor (i, obs) in enumerate(observations)\n    Nt = length(obs.times)\n    t = obs.times[end]\n    fields = map(name -> interior(obs.field_time_serieses[name][Nt], 1, 1, :), field_names)\n    plot_fields!(axs, fields..., \"t = \" * prettytime(t), colorcycle[i])\nend\n\n[axislegend(ax, position=:rb, merge=true, fontsize=10) for ax in axs]\n\nsave(\"multi_case_lesbrary_synthetic_observations.svg\", fig); nothing # hide","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"(Image: )","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/#Calibration","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration","text":"","category":"section"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"ri_based_closure = RiBasedVerticalDiffusivity()\n\nsimulation = ensemble_column_model_simulation(observations;\n                                              Nensemble = 60,\n                                              architecture = CPU(),\n                                              tracers = (:b, :e),\n                                              closure = ri_based_closure)","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"The simulation is initialized with neutral boundary conditions and a default time-step, which we modify for our particular problem:","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"Qᵘ = simulation.model.velocities.u.boundary_conditions.top.condition\nQᵇ = simulation.model.tracers.b.boundary_conditions.top.condition\nN² = simulation.model.tracers.b.boundary_conditions.bottom.condition\n\nsimulation.Δt = 20minutes\n\nfor (i, obs) in enumerate(observations)\n    view(Qᵘ, :, i) .= obs.metadata.parameters.momentum_flux\n    view(Qᵇ, :, i) .= obs.metadata.parameters.buoyancy_flux\n    view(N², :, i) .= obs.metadata.parameters.N²_deep\nend","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"We identify a subset of the closure parameters to calibrate by specifying parameter names and prior distributions:","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"priors = (ν₀   = lognormal(mean=0.01, std=0.005),\n          κ₀   = lognormal(mean=0.1,  std=0.05),\n          Ri₀ν = Normal(-0.5, 1.0),\n          Ri₀κ = Normal(-0.5, 1.0),\n          Riᵟν = lognormal(mean=1.0,  std=0.5),\n          Riᵟκ = lognormal(mean=1.0,  std=0.5))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"TODO: explain the meaning of each parameter The prior information comes from experience, prior calibration runs, and educated guesses.","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"calibration = InverseProblem(observations, simulation, free_parameters)","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"Next, we calibrate, using a relatively large noise to reflect our uncertainty about how close the observations and model can really get,","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"eki = EnsembleKalmanInversion(calibration; pseudo_stepping=ConstantConvergence(0.8))\niterate!(eki; iterations = 10)\n@show eki.iteration_summaries[end]","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/#Results","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Results","text":"","category":"section"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"To analyze the reuslts, we build a new simulation with just one ensemble member to evaluate pasome utilities for analyzing the results:","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"Nt = length(first(observations).times)\nNiter = length(eki.iteration_summaries) - 1\nmodeled_time_serieses = calibration.time_series_collector.field_time_serieses\n\nobserved, modeled = [], []\nfor (c, obs) in enumerate(observations)\n    push!(observed, map(name -> interior(obs.field_time_serieses[name][Nt], 1, 1, :), field_names))\n    push!(modeled,  map(name -> interior(  modeled_time_serieses[name][Nt], 1, c, :), field_names))\nend\n\nfunction compare_model_observations(model_label=\"modeled\")\n    fig, axs = make_figure_axes(length(observations))\n    for (c, obs) in enumerate(observations)\n        plot_fields!(axs[c], observed[c]..., \"observed at t = \" * prettytime(times[end]), :black)\n        plot_fields!(axs[c], modeled[c]..., model_label, :blue)\n        [axislegend(ax, position=:rb, merge=true, fontsize=10) for ax in axs[c]]\n    end\n    return fig\nend","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"Now we execute forward runs for the initial ensemble mean,","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"initial_parameters = eki.iteration_summaries[0].ensemble_mean\nforward_run!(calibration, initial_parameters)\nfig = compare_model_observations(\"modeled after 0 iterations\")\n\nsave(\"multi_case_model_observation_comparison_iteration_0.svg\", fig); nothing # hide","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"(Image: )","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"and the final ensemble mean, representing our \"best\" parameter set,","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"best_parameters = eki.iteration_summaries[end].ensemble_mean\nforward_run!(calibration, best_parameters)\nfig = compare_model_observations(\"modeled after $Niter iterations\")\n\nsave(\"multi_case_model_observation_comparison_final_iteration.svg\", fig); nothing # hide","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"(Image: )","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/#Parameter-evolution","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Parameter evolution","text":"","category":"section"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"To understand how results changed over the EKI iterations, we look at the evoluation of the ensemble means,","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"ensemble_means = NamedTuple(n => map(summary -> summary.ensemble_mean[n], eki.iteration_summaries)\n                            for n in calibration.free_parameters.names)\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"Ensemble Kalman iteration\", ylabel = \"Parameter value\")\n\nfor (i, name) in enumerate(calibration.free_parameters.names)\n    label = string(name)\n    marker = markercycle[i]\n    color = colorcycle[i]\n    scatterlines!(ax, 0:Niter, parent(ensemble_means[name]); marker, color, label)\nend\n\naxislegend(ax, position=:rb)\n\nsave(\"lesbrary_catke_parameter_evolution.svg\", fig); nothing # hide","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"(Image: )","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"","category":"page"},{"location":"literated/multi_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","title":"Calibration of RiBasedVerticalDiffusivity to five LESbrary simulations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation Instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"You can install the latest version of ParameterEstimocean.jl via the built-in package manager (by pressing ] in the Julia REPL command prompt) to add the package and also to  instantiate/build all the required dependencies","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"To install, use Julia's  built-in package manager (accessed by pressing ] in the Julia REPL command prompt) to add the package and also to instantiate/build all the required dependencies. The package is not yet included in Julia's official registry so you need to install via Github.","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"To install a tagged version of the package, e.g., v0.6.0, use","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"julia>]\n(v1.6) pkg> add https://github.com/CliMA/ParameterEstimocean.jl#v0.6.0\n(v1.6) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"Alternatively, if you'd like to be in the bleeding edge of the package's latest developments you may install the version on the #main branch (or any other branch or commit), e.g.","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"julia>]\n(v1.6) pkg> add https://github.com/CliMA/ParameterEstimocean.jl#main\n(v1.6) pkg> instantiate","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"EditURL = \"https://github.com/CliMA/ParameterEstimocean.jl/blob/main/examples/intro_to_inverse_problems.jl\"","category":"page"},{"location":"literated/intro_to_inverse_problems/#Intro-to-InverseProblem","page":"Intro to inverse problems","title":"Intro to InverseProblem","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"This example illustrates the construction of an \"ensemble simulation\" that can evaluate an ensemble of column models given an ensemble of free parameter sets. The example then builds an InverseProblem from observations, an ensemble simulation, and a set of free parameters, and illustrates its basic usage.","category":"page"},{"location":"literated/intro_to_inverse_problems/#Install-dependencies","page":"Intro to inverse problems","title":"Install dependencies","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"using Pkg\npkg\"add ParameterEstimocean, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"First we load few things","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"using ParameterEstimocean\n\nusing Oceananigans\nusing Oceananigans.Architectures: arch_array\nusing Oceananigans.Units\nusing Oceananigans.Models.HydrostaticFreeSurfaceModels: ColumnEnsembleSize\nusing Oceananigans.TurbulenceClosures: ConvectiveAdjustmentVerticalDiffusivity\n\nusing CairoMakie\nusing Distributions\nusing JLD2","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"We reuse some utilities from a previous example to build observations:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"examples_path = joinpath(pathof(ParameterEstimocean), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_observations.jl\"))\ndata_path = generate_synthetic_observations()\nobservations = SyntheticObservations(data_path, field_names=:b, transformation=ZScore())","category":"page"},{"location":"literated/intro_to_inverse_problems/#Building-an-\"ensemble-simulation\"","page":"Intro to inverse problems","title":"Building an \"ensemble simulation\"","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"Our next task is to construct a parameterized Oceananigans.Simulation that generates the \"foward map\" for an ensemble of free parameter sets. To generate an ensemble of column model model outputs efficiently, we construct one 3D Oceananigans.Simulation consisting of Nx by Ny independent column models.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"The calibration problem then uses the ensemble simulation to find optimal parameters by minimizing the discrepency between the observations and the forward map.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"\"\"\"\n    extract_perfect_parameters(observations, Nensemble)\n\nExtract parameters from a batch of \"perfect\" observations.\n\"\"\"\nfunction extract_perfect_parameters(observations, Nensemble)\n    Nbatch = length(observations)\n    Qᵘ, Qᵇ, N², f = [zeros(Nensemble, Nbatch) for i = 1:4]\n\n    Nz = first(observations).grid.Nz\n    Hz = first(observations).grid.Hz\n    Lz = first(observations).grid.Lz\n    Δt = first(observations).metadata.parameters.Δt\n\n    for (j, obs) in enumerate(observations)\n        Qᵘ[:, j] .= obs.metadata.parameters.Qᵘ\n        Qᵇ[:, j] .= obs.metadata.parameters.Qᵇ\n        N²[:, j] .= obs.metadata.parameters.N²\n        f[:, j] .= obs.metadata.coriolis.f\n    end\n\n    file = jldopen(first(observations).path)\n    closure = file[\"serialized/closure\"]\n    close(file)\n\n    return Qᵘ, Qᵇ, N², f, Δt, Lz, Nz, Hz, closure\nend\n\n\"\"\"\n    build_ensemble_simulation(observations, arch=CPU(); Nensemble=1)\n\nReturns an `Oceananigans.Simulation` representing an `Nensemble × 1`\nensemble of column models designed to reproduce `observations`.\n\"\"\"\nfunction build_ensemble_simulation(observations, arch=CPU(); Nensemble=1)\n\n    observations isa Vector || (observations = [observations]) # Singleton batch\n    Nbatch = length(observations)\n\n    Qᵘ, Qᵇ, N², f, Δt, Lz, Nz, Hz, closure = extract_perfect_parameters(observations, Nensemble)\n\n    column_ensemble_size = ColumnEnsembleSize(Nz=Nz, ensemble=(Nensemble, Nbatch), Hz=Hz)\n    ensemble_grid = RectilinearGrid(arch, size = column_ensemble_size, topology = (Flat, Flat, Bounded), z = (-Lz, 0))\n\n    coriolis_ensemble = arch_array(arch, [FPlane(f=f[i, j]) for i = 1:Nensemble, j=1:Nbatch])\n    closure_ensemble = arch_array(arch, [deepcopy(closure) for i = 1:Nensemble, j=1:Nbatch])\n\n    Qᵘ, Qᵇ, N² = Tuple(arch_array(arch, p) for p in (Qᵘ, Qᵇ, N²))\n\n    u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ))\n    b_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵇ), bottom = GradientBoundaryCondition(N²))\n\n    tracers = first(observations).metadata.parameters.tracers\n\n    ensemble_model = HydrostaticFreeSurfaceModel(grid = ensemble_grid,\n                                                 tracers = tracers,\n                                                 buoyancy = BuoyancyTracer(),\n                                                 boundary_conditions = (; u=u_bcs, b=b_bcs),\n                                                 coriolis = coriolis_ensemble,\n                                                 closure = closure_ensemble)\n\n    ensemble_simulation = Simulation(ensemble_model; Δt=Δt, stop_time=first(observations).times[end])\n\n    return ensemble_simulation, closure\nend","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"The following illustrations uses a simple ensemble simulation with two ensemble members:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"ensemble_simulation, closure★ = build_ensemble_simulation(observations; Nensemble=3)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Free-parameters","page":"Intro to inverse problems","title":"Free parameters","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"We construct some prior distributions for our free parameters. We found that it often helps to constrain the prior distributions so that neither very high nor very low values for diffusivities can be drawn out of the distribution.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"priors = (convective_κz = lognormal(mean=0.3, std=0.05),\n          background_κz = lognormal(mean=2.5e-4, std=0.25e-4))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"We also take the opportunity to collect a named tuple of the optimal parameters","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"θ★ = (convective_κz = closure★.convective_κz,\n      background_κz = closure★.background_κz)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Visualizing-the-priors","page":"Intro to inverse problems","title":"Visualizing the priors","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"We visualize our prior distributions by plotting a huge number of samples:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"using ParameterEstimocean.Parameters: unconstrained_prior, transform_to_constrained\n\nNsamples = 50000000\n\nsample(prior) = [transform_to_constrained(prior, X) for X in rand(unconstrained_prior(prior), Nsamples)]\n\nconvective_κz_samples = sample(priors.convective_κz)\nbackground_κz_samples = sample(priors.background_κz)\n\nfig = Figure()\nax_top = Axis(fig[1, 1], xlabel = \"convective κᶻ [m² s⁻¹]\", ylabel = \"Density\")\ndensity!(ax_top, convective_κz_samples)\nxlims!(ax_top, 0, 10)\n\nax_bottom = Axis(fig[2, 1], xlabel = \"background κᶻ [m² s⁻¹]\", ylabel = \"Density\")\ndensity!(ax_bottom, background_κz_samples)\n\nsave(\"prior_visualization.svg\", fig)\nnothing # hide","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"(Image: )","category":"page"},{"location":"literated/intro_to_inverse_problems/#The-InverseProblem","page":"Intro to inverse problems","title":"The InverseProblem","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"We can construct the inverse problem y = G(θ) + η. Here, y are the observations and G is the ensemble_model.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Using-InverseProblem-to-compute-forward_map","page":"Intro to inverse problems","title":"Using InverseProblem to compute forward_map","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"As a sanity check we apply the forward_map on the calibration after we initialize all ensemble members with the true parameter values. We then confirm that the output of the forward_map matches the observations to machine precision.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"θ¹ = (convective_κz = 0.8 * θ★.convective_κz,\n      background_κz = 9.0 * θ★.background_κz)\n\nθ² = (convective_κz = 2.0 * θ★.convective_κz,\n      background_κz = 0.1 * θ★.background_κz)\n\nθ_ensemble = [θ★, θ¹, θ²]\n\nG = forward_map(calibration, θ_ensemble)\ny = observation_map(calibration)","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"The forward_map output G is a two-dimensional matrix whose first dimension is the size of the state space and whose second dimension is the ensemble_size. Here, we ensure that first ensemble member of the mapped output, which was run with the \"true\" parameters, is identical to the mapped observations:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"G[:, 1] ≈ y","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"Visualizing forward model output","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"Next we visualize the discrepency between solutions generated by true and non-optimal parameter sets θ¹ and θ². Time-series data from the ensemble run is collected by calibration.time_series_collector:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"time_series_collector = calibration.time_series_collector\ntimes = time_series_collector.times\n\n# Extract last save point and plot each solution component\nNt = length(times)\n\nb = time_series_collector.field_time_serieses.b[Nt]\nt = times[Nt]\nz = znodes(b)\n\n# The ensemble varies along the first, or `x`-dimension:\nb★ = interior(b)[1, 1, :]\nb¹ = interior(b)[2, 1, :]\nb² = interior(b)[3, 1, :]\n\nfig = Figure()\nax = Axis(fig[1, 1],\n          xlabel = \"Buoyancy [m s⁻²]\",\n          ylabel = \"Depth [m]\")\n\nb★_label = \"true b at t = \" * prettytime(t)\nb¹_label = \"b with $θ¹\"\nb²_label = \"b with $θ²\"\n\nlines!(ax, b★, z; label=b★_label, linewidth=2)\nlines!(ax, b¹, z; label=b¹_label, linewidth=2)\nlines!(ax, b², z; label=b²_label, linewidth=2)\n\naxislegend(ax, position=:lt)\n\nsave(\"ensemble_simulation_demonstration.svg\", fig); nothing # hide","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"(Image: )","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"EditURL = \"https://github.com/CliMA/ParameterEstimocean.jl/blob/main/examples/single_case_lesbrary_ri_based_calibration.jl\"","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/#Calibration-of-RiBasedVerticalDiffusivity-to-one-LESbrary-simulation","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"","category":"section"},{"location":"literated/single_case_lesbrary_ri_based_calibration/#Install-dependencies","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Install dependencies","text":"","category":"section"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"using Pkg\npkg\"add ParameterEstimocean, Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"using Oceananigans\nusing Oceananigans.Units\nusing ParameterEstimocean\nusing LinearAlgebra, CairoMakie, DataDeps, Distributions\n\nusing Oceananigans.TurbulenceClosures: RiBasedVerticalDiffusivity","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/#Using-LESbrary-data","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Using LESbrary data","text":"","category":"section"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"ParameterEstimocean.jl provides paths to synthetic observations derived from high-fidelity large eddy simulations. In this example, we illustrate calibration of a turbulence parameterization to one of these simulations:","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"datapath = datadep\"two_day_suite_1m/strong_wind_instantaneous_statistics.jld2\"\ntimes = [2hours, 12hours, 24hours]\nfield_names = (:b, :u, :v)\ntransformation = ZScore()\nregrid = (1, 1, 32)\n\nobservations = SyntheticObservations(datapath; field_names, times, transformation, regrid)","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"Let's take a look at the observations. We define a few plotting utilities along the way to use later in the example:","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"colorcycle = [:black, :red, :darkblue, :orange, :pink1, :seagreen, :magenta2]\nmarkercycle = [:rect, :utriangle, :star5, :circle, :cross, :+, :pentagon]\n\nfunction make_figure_axes()\n    fig = Figure(resolution=(1200, 400))\n    ax_b = Axis(fig[1, 1], xlabel = \"Buoyancy \\n[cm s⁻²]\", ylabel = \"z [m]\")\n    ax_u = Axis(fig[1, 2], xlabel = \"x-velocity, u \\n[cm s⁻¹]\")\n    ax_v = Axis(fig[1, 3], xlabel = \"y-velocity, v \\n[cm s⁻¹]\")\n    return fig, (ax_b, ax_u, ax_v)\nend\n\nfunction plot_fields!(axs, b, u, v, label, color)\n    z = znodes(Center, b.grid)\n    # Note unit conversions below, eg m s⁻² -> cm s⁻²:\n    lines!(axs[1], 1e2 * interior(b, 1, 1, :), z; color, label)\n    lines!(axs[2], 1e2 * interior(u, 1, 1, :), z; color, label)\n    lines!(axs[3], 1e2 * interior(v, 1, 1, :), z; color, label)\n    return nothing\nend","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"And then plot the evolution of the observed fields,","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"fig, axs = make_figure_axes()\n\nfor (i, t) in enumerate(times)\n    fields = map(name -> observations.field_time_serieses[name][i], field_names)\n    plot_fields!(axs, fields..., \"t = \" * prettytime(t), colorcycle[i])\nend\n\n[axislegend(ax, position=:rb, merge=true, fontsize=10) for ax in axs]\n\nsave(\"lesbrary_synthetic_observations.svg\", fig); nothing # hide","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"(Image: )","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"Behold, boundary layer turbulence!","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/#Calibration","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration","text":"","category":"section"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"Next, we build a simulation of an ensemble of column models to calibrate the closure using Ensemble Kalman Inversion. We configure the closure without convective adjustment and with constant (rather than Richardson-number-dependent) diffusivity parameters.","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"ri_based_closure = RiBasedVerticalDiffusivity()\n\nsimulation = ensemble_column_model_simulation(observations;\n                                              Nensemble = 60,\n                                              architecture = CPU(),\n                                              tracers = (:b, :e),\n                                              closure = ri_based_closure)","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"The simulation is initialized with neutral boundary conditions and a default time-step, which we modify for our particular problem:","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"Qᵘ = simulation.model.velocities.u.boundary_conditions.top.condition\nQᵇ = simulation.model.tracers.b.boundary_conditions.top.condition\nN² = simulation.model.tracers.b.boundary_conditions.bottom.condition\n\nsimulation.Δt = 20minutes\n\nQᵘ .= observations.metadata.parameters.momentum_flux\nQᵇ .= observations.metadata.parameters.buoyancy_flux\nN² .= observations.metadata.parameters.N²_deep","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"We identify a subset of the closure parameters to calibrate by specifying parameter names and prior distributions:","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"priors = (ν₀   = lognormal(mean=0.01, std=0.005),\n          κ₀   = lognormal(mean=0.1,  std=0.05),\n          Ri₀ν = Normal(-0.5, 1.0),\n          Ri₀κ = Normal(-0.5, 1.0),\n          Riᵟν = lognormal(mean=1.0,  std=0.5),\n          Riᵟκ = lognormal(mean=1.0,  std=0.5))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"TODO: explain the meaning of each parameter The prior information comes from experience, prior calibration runs, and educated guesses.","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"calibration = InverseProblem(observations, simulation, free_parameters)","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"Next, we calibrate, using a relatively large noise to reflect our uncertainty about how close the observations and model can really get,","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"eki = EnsembleKalmanInversion(calibration; pseudo_stepping=ConstantConvergence(0.8))\niterate!(eki; iterations = 10)\n\n@show eki.iteration_summaries[end]","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/#Results","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Results","text":"","category":"section"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"To analyze the reuslts, we build a new simulation with just one ensemble member to evaluate pasome utilities for analyzing the results:","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"Nt = length(observations.times)\nNiter = length(eki.iteration_summaries) - 1\nmodeled_time_serieses = calibration.time_series_collector.field_time_serieses\nobserved = map(name -> observations.field_time_serieses[name][Nt], field_names)\nmodeled = map(name -> modeled_time_serieses[name][Nt], field_names)\n\nfunction compare_model_observations(model_label=\"modeled\")\n    fig, axs = make_figure_axes()\n    plot_fields!(axs, observed..., \"observed at t = \" * prettytime(times[end]), :black)\n    plot_fields!(axs, modeled..., model_label, :blue)\n    [axislegend(ax, position=:rb, merge=true, fontsize=10) for ax in axs]\n    return fig\nend","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"Now we execute forward runs for the initial ensemble mean,","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"initial_parameters = eki.iteration_summaries[0].ensemble_mean\nforward_run!(calibration, initial_parameters)\nfig = compare_model_observations(\"modeled after 0 iterations\")\n\nsave(\"model_observation_comparison_iteration_0.svg\", fig); nothing # hide","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"(Image: )","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"and the final ensemble mean, representing our \"best\" parameter set,","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"best_parameters = eki.iteration_summaries[end].ensemble_mean\nforward_run!(calibration, best_parameters)\nfig = compare_model_observations(\"modeled after $Niter iterations\")\n\nsave(\"model_observation_comparison_final_iteration.svg\", fig); nothing # hide","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"(Image: )","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/#Parameter-evolution","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Parameter evolution","text":"","category":"section"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"To understand how results changed over the EKI iterations, we look at the evoluation of the ensemble means,","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"ensemble_means = NamedTuple(n => map(summary -> summary.ensemble_mean[n], eki.iteration_summaries)\n                            for n in calibration.free_parameters.names)\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"Ensemble Kalman iteration\", ylabel = \"Parameter value\")\n\nfor (i, name) in enumerate(calibration.free_parameters.names)\n    label = string(name)\n    marker = markercycle[i]\n    color = colorcycle[i]\n    scatterlines!(ax, 0:Niter, parent(ensemble_means[name]); marker, color, label)\nend\n\naxislegend(ax, position=:rb)\n\nsave(\"lesbrary_catke_parameter_evolution.svg\", fig); nothing # hide","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"(Image: )","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"","category":"page"},{"location":"literated/single_case_lesbrary_ri_based_calibration/","page":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","title":"Calibration of RiBasedVerticalDiffusivity to one LESbrary simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/internals/#Private-types-and-functions","page":"Private","title":"Private types and functions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Documentation for ParameterEstimocean.jl's internal interface.","category":"page"},{"location":"library/internals/#ParameterEstimocean","page":"Private","title":"ParameterEstimocean","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ParameterEstimocean]\nPublic = false\nPages   = [\"ParameterEstimocean.jl\"]","category":"page"},{"location":"library/internals/#Transformations","page":"Private","title":"Transformations","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ParameterEstimocean.Transformations]\nPublic = false\nPages   = [\"Transformations.jl\"]","category":"page"},{"location":"library/internals/#ParameterEstimocean.Transformations.compute_normalization-Tuple{ZScore{Nothing}, Any, Any}","page":"Private","title":"ParameterEstimocean.Transformations.compute_normalization","text":"Compute ZScore on time- and space-transformed field time series data.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Transformations.compute_time_transformation-Tuple{Nothing, Any}","page":"Private","title":"ParameterEstimocean.Transformations.compute_time_transformation","text":"compute_time_transformation(user_time_transformation, fts)\n\nCompute a time transformation for the field time series fts given user_time_transformation.\n\nBy default, if user_time_transformation isa nothing, then we include all time instances except the initial condition.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Observations","page":"Private","title":"Observations","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ParameterEstimocean.Observations]\nPublic = false","category":"page"},{"location":"library/internals/#ParameterEstimocean.Observations.FieldTimeSeriesCollector-Tuple{Any, Any}","page":"Private","title":"ParameterEstimocean.Observations.FieldTimeSeriesCollector","text":"FieldTimeSeriesCollector(collected_fields, times;\n                         architecture = Architectures.architecture(first(collected_fields)))\n\nReturn a FieldTimeSeriesCollector for fields of simulation. fields is a NamedTuple of AbstractFields that are to be collected.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Observations.column_ensemble_interior-Tuple{Vector{var\"#s86\"} where var\"#s86\"<:SyntheticObservations, Any, Any, Any}","page":"Private","title":"ParameterEstimocean.Observations.column_ensemble_interior","text":"column_ensemble_interior(observations::Vector{<:SyntheticObservations},\n                         field_name, time_index, (Nensemble, Nbatch, Nz))\n\nReturn an Nensemble × Nbatch × Nz Array of (1, 1, Nz) field_name data, given Nbatch SyntheticObservations objects. The Nbatch × Nz data for field_name is copied Nensemble times to form a 3D Array.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Observations.forward_map_names-Tuple{Vector{var\"#s89\"} where var\"#s89\"<:SyntheticObservations}","page":"Private","title":"ParameterEstimocean.Observations.forward_map_names","text":"forward_map_names(observations::Vector{<:SyntheticObservations})\n\nReturn a Set representing the union of all names in obs.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Observations.observation_names-Tuple{Vector{var\"#s89\"} where var\"#s89\"<:SyntheticObservations}","page":"Private","title":"ParameterEstimocean.Observations.observation_names","text":"observation_names(observations::Vector{<:SyntheticObservations})\n\nReturn a Set representing the union of all names in obs.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Ensemble-Simulations","page":"Private","title":"Ensemble Simulations","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ParameterEstimocean.EnsembleSimulations]\nPublic = false","category":"page"},{"location":"library/internals/#Parameters","page":"Private","title":"Parameters","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ParameterEstimocean.Parameters]\nPublic = false","category":"page"},{"location":"library/internals/#ParameterEstimocean.Parameters.closure_with_parameters-Tuple{Any, Any}","page":"Private","title":"ParameterEstimocean.Parameters.closure_with_parameters","text":"closure_with_parameters(closure, parameters)\n\nReturn a new object where for each (parameter_name, parameter_value) pair  in parameters, the value corresponding to the key in closure that matches parameter_name is replaced with parameter_value.\n\nExample\n\nCreate a placeholder Closure type that includes a parameter c and a sub-closure with two parameters: a and b. Then construct a closure with values a, b, c = 1, 2, 3.\n\njulia> struct Closure; subclosure; c end\n\njulia> struct ClosureSubModel; a; b end\n\njulia> sub_closure = ClosureSubModel(1, 2)\nClosureSubModel(1, 2)\n\njulia> closure = Closure(sub_closure, 3)\nClosure(ClosureSubModel(1, 2), 3)\n\nProviding closure_with_parameters with a named tuple of parameter names and values, and a recursive search in all types and subtypes within closure is done and whenever a parameter is found whose name exists in the named tuple we provided, its value is  then replaced with the value provided.\n\njulia> new_parameters = (a = 12, d = 7)\n(a = 12, d = 7)\n\njulia> using ParameterEstimocean.Parameters: closure_with_parameters\n\njulia> closure_with_parameters(closure, new_parameters)\nClosure(ClosureSubModel(12, 2), 3)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Parameters.construct_object-Tuple{Union{Number, AbstractArray}, Any}","page":"Private","title":"ParameterEstimocean.Parameters.construct_object","text":"construct_object(specification_dict, parameters; name=nothing, type_parameter=nothing)\n\nconstruct_object(d::ParameterValue, parameters; name=nothing)\n\nReturn a composite type object whose properties are prescribed by the specification_dict dictionary. All parameter values are given the values in specification_dict unless they are included as a parameter name-value pair in the named tuple parameters, in which case the value in parameters is asigned.\n\nThe construct_object is recursively called upon every property that is included in specification_dict until a property with a numerical value is reached. The object's constructor name must be included in specification_dict under key :type.\n\nExample\n\njulia> using ParameterEstimocean.Parameters: construct_object, dict_properties, closure_with_parameters\n\njulia> struct Closure; subclosure; c end\n\njulia> struct ClosureSubModel; a; b end\n\njulia> sub_closure = ClosureSubModel(1, 2)\nClosureSubModel(1, 2)\n\njulia> closure = Closure(sub_closure, 3)\nClosure(ClosureSubModel(1, 2), 3)\n\njulia> specification_dict = dict_properties(closure)\nDict{Symbol, Any} with 3 entries:\n  :type       => Closure\n  :c          => 3\n  :subclosure => Dict{Symbol, Any}(:a=>1, :b=>2, :type=>ClosureSubModel)\n\njulia> new_closure = construct_object(specification_dict, (a=2.1,))\nClosure(ClosureSubModel(2.1, 2), 3)\n  \njulia> another_new_closure = construct_object(specification_dict, (b=π, c=2π))\nClosure(ClosureSubModel(1, π), 6.283185307179586)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Parameters.dict_properties-Tuple{Any}","page":"Private","title":"ParameterEstimocean.Parameters.dict_properties","text":"dict_properties(object)\n\nReturn a dictionary with all properties of an object and their values, including the  object's type name. If any of the object's properties is not a numerical value but instead a composite type, then dict_properties is called recursively on that object's property returning a dictionary with all properties of that composite type. Recursion ends when properties of type ParameterValue are found.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Parameters.new_closure_ensemble-Tuple{AbstractArray, Any, Any}","page":"Private","title":"ParameterEstimocean.Parameters.new_closure_ensemble","text":"new_closure_ensemble(closures, θ, arch=CPU())\n\nReturn a new set of closures in which all closures that have free parameters are updated. Closures with free parameters are expected as AbstractArray of TurbulenceClosures, and this allows new_closure_ensemble to go through all closures in closures and only update the parameters for the any closure that is of type AbstractArray. The architecture (CPU() or GPU()) defines whethere Array or CuArray is returned.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Parameters.normal_to_scaled_logit_normal-Tuple{Any, Any, Any}","page":"Private","title":"ParameterEstimocean.Parameters.normal_to_scaled_logit_normal","text":"Return a logit-normally distributed variate given the normally-distributed variate X.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Parameters.scaled_logit_normal_to_normal-Tuple{Any, Any, Any}","page":"Private","title":"ParameterEstimocean.Parameters.scaled_logit_normal_to_normal","text":"Return a normally-distributed variate given the logit-normally distributed variate Y.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Parameters.transform_to_constrained-Tuple{Normal, Any}","page":"Private","title":"ParameterEstimocean.Parameters.transform_to_constrained","text":"transform_to_constrained(Π, X)\n\nTransform an \"unconstrained\", normally-distributed variate X to \"constrained\" (physical) space via the map associated with the distribution Π of Y.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Parameters.transform_to_unconstrained-Tuple{Normal, Any}","page":"Private","title":"ParameterEstimocean.Parameters.transform_to_unconstrained","text":"transform_to_unconstrained(Π, Y)\n\nTransform the \"constrained\" (physical) variate Y into it's unconstrained (normally-distributed) counterpart X through the forward map associated with Π.\n\nIf some mapping between Y and the normally-distributed X is defined via\n\nY = g(X)\n\nThen transform_to_unconstrained is the inverse X = g^-1(Y). The change of variables g(X) determines the distribution Π of Y.\n\nExample\n\nThe logarithm of a LogNormal(μ, σ) distributed variate is normally-distributed, such that the forward trasform f  exp,\n\nY = exp(X)\n\nand the inverse trasnform is the natural logarithm f^-1  log,\n\nlog(Y) = X  𝒩(μ σ)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.Parameters.update_closure_ensemble_member!-Tuple{Any, Any, Any}","page":"Private","title":"ParameterEstimocean.Parameters.update_closure_ensemble_member!","text":"update_closure_ensemble_member!(closures, p_ensemble, parameters)\n\nUse parameters to update the p_ensemble-th closure from and array of closures. The p_ensemble-th closure corresponds to ensemble member p_ensemble.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Inverse-Problems","page":"Private","title":"Inverse Problems","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ParameterEstimocean.InverseProblems]\nPublic = false","category":"page"},{"location":"library/internals/#ParameterEstimocean.InverseProblems.ConcatenatedVectorNormMap","page":"Private","title":"ParameterEstimocean.InverseProblems.ConcatenatedVectorNormMap","text":"struct ConcatenatedVectorNormMap()\n\nForward map transformation of simulation output to a scalar by taking a naive norm of the difference between concatenated vectors of the observations and simulation output.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#ParameterEstimocean.InverseProblems.expand_parameters-Tuple{Any, Vector{T} where T}","page":"Private","title":"ParameterEstimocean.InverseProblems.expand_parameters","text":"expand_parameters(ip, θ)\n\nConvert θ to Vector{<:NamedTuple}, where the elements correspond to ip.free_parameters.\n\nθ may represent an ensemble of parameter sets via:\n\nθ::Vector{<:Vector} (caution: parameters must be ordered correctly!)\nθ::Matrix (caution: parameters must be ordered correctly!)\nθ::Vector{<:NamedTuple} \n\nor a single parameter set if θ::Vector{<:Number}.\n\nIf length(θ) is less the the number of ensemble members in ip.simulation, the last parameter set is copied to fill the parameter set ensemble.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.InverseProblems.inverting_forward_map-Tuple{InverseProblem, Any}","page":"Private","title":"ParameterEstimocean.InverseProblems.inverting_forward_map","text":"inverting_forward_map(ip::InverseProblem, X)\n\nTransform unconstrained parameters X into constrained, physical-space parameters θ and execute forward_map(ip, θ).\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.InverseProblems.transform_time_series-Tuple{Any, Vector{T} where T}","page":"Private","title":"ParameterEstimocean.InverseProblems.transform_time_series","text":"transform_time_series(map, batched_observations::Vector)\n\nConcatenate the output of transform_time_series of each observation in batched_observations.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.InverseProblems.transform_time_series-Tuple{ConcatenatedOutputMap, SyntheticObservations}","page":"Private","title":"ParameterEstimocean.InverseProblems.transform_time_series","text":"transform_time_series(::ConcatenatedOutputMap, observation::SyntheticObservations)\n\nTransforms, normalizes, and concatenates data for field time series in observation.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.InverseProblems.transpose_model_output-Tuple{Oceananigans.Grids.AbstractGrid{var\"#s1451\", var\"#s1450\", var\"#s1449\", var\"#s1448\", Arch} where {var\"#s1451\"<:AbstractFloat, var\"#s1450\"<:Oceananigans.Grids.Flat, var\"#s1449\"<:Oceananigans.Grids.Flat, var\"#s1448\"<:Oceananigans.Grids.Bounded, Arch}, Any, Any}","page":"Private","title":"ParameterEstimocean.InverseProblems.transpose_model_output","text":"transpose_model_output(time_series_collector, observations)\n\nTranspose a NamedTuple of 4D FieldTimeSeries model output collected by time_series_collector into a Vector of SyntheticObservations for each member of the observation batch.\n\nReturn a 1-vector in the case of singleton observations.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#EnsembleKalmanInversions","page":"Private","title":"EnsembleKalmanInversions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ParameterEstimocean.EnsembleKalmanInversions]\nPublic = false","category":"page"},{"location":"library/internals/#ParameterEstimocean.EnsembleKalmanInversions.IterationSummary","page":"Private","title":"ParameterEstimocean.EnsembleKalmanInversions.IterationSummary","text":"IterationSummary(eki, X, forward_map_output=nothing)\n\nReturn the summary for ensemble Kalman inversion eki with unconstrained parameters X and forward_map_output.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#ParameterEstimocean.EnsembleKalmanInversions.column_has_nan-Tuple{Any}","page":"Private","title":"ParameterEstimocean.EnsembleKalmanInversions.column_has_nan","text":"Return a BitVector indicating which particles are NaN.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.EnsembleKalmanInversions.eki_objective-Tuple{Any, AbstractVector{T} where T, AbstractVector{T} where T}","page":"Private","title":"ParameterEstimocean.EnsembleKalmanInversions.eki_objective","text":"eki_objective(eki, θ, G)\n\nGiven forward map G and parameters θ, return a tuple (Φ₁, Φ₂)  of terms in the EKI regularized objective function, where\n\nΦ = Φ₁ + Φ₂\n\nΦ₁ measures output misfit (1/2)*|| Γy^(-¹/₂) * (y .- G(θ)) ||² and  Φ₂ measures prior misfit (1/2)*|| Γθ^(-¹/₂) * (θ .- μθ) ||², where y is the observation  map, G(θ) is the forward map, Γy is the observation noise covariance, Γθ is  the prior covariance, and μθ represents the prior means. Note that Γ^(-1/2) =  inv(sqrt(Γ)). The keyword argument constrained is true if the input θ represents constrained parameters.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.EnsembleKalmanInversions.find_successful_particles-NTuple{4, Any}","page":"Private","title":"ParameterEstimocean.EnsembleKalmanInversions.find_successful_particles","text":" find_successful_particles(eki, X, G, Nsample)\n\nGenerate Nsample new particles sampled from a multivariate Normal distribution parameterized  by the ensemble mean and covariance computed based on the Nθ × Nensemble ensemble  array θ, under the condition that all Nsample particles produce successful forward map outputs (don't include NaNs).\n\nG (size(G) =  Noutput × Nensemble) is the forward map output produced by θ.\n\nReturns Nθ × Nsample parameter Array and Noutput × Nsample forward map output Array.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ParameterEstimocean.EnsembleKalmanInversions.resample!-Tuple{Resampler, Any, Any, Any}","page":"Private","title":"ParameterEstimocean.EnsembleKalmanInversions.resample!","text":"resample!(resampler::Resampler, θ, G, eki)\n\nResamples the parameters θ of the eki process based on the number of NaN values inside the forward map output G.\n\n\n\n\n\n","category":"method"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/ParameterEstimocean.jl/blob/main/examples/perfect_baroclinic_adjustment_calibration.jl\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Perfect-baroclinic-adjustment-calibration-with-Ensemble-Kalman-Inversion","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"This example showcases a \"perfect model calibration\" of the two-dimensional baroclinic adjustement problem (depth-latitude) with eddies parametrized using Gent-McWilliams–Redi isoneutral diffusion closure. We use output for buoyancy (b) and a passive-tracer concentration (c) to calibrate the parametrization.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Install-dependencies","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using Pkg\npkg\"add Oceananigans, Distributions, CairoMakie, ParameterEstimocean\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First we load few things","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using ParameterEstimocean\n\nusing Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.TurbulenceClosures: FluxTapering\nusing Oceananigans.Models.HydrostaticFreeSurfaceModels: SliceEnsembleSize\nusing Distributions\nusing Printf\nusing LinearAlgebra: norm","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Set-up-the-problem-and-generate-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Set up the problem and generate observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Define the  \"true\" skew and symmetric diffusivity coefficients. These are the parameter values that we use to generate the data. Then, we'll see if the EKI calibration can recover these values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"κ_skew = 1000.0       # [m² s⁻¹] skew diffusivity\nκ_symmetric = 900.0   # [m² s⁻¹] symmetric diffusivity\nnothing # hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We gather the \"true\" parameters in a named tuple θ_*:","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"θ★ = (; κ_skew, κ_symmetric)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The experiment name and where the synthetic observations will be saved.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"experiment_name = \"baroclinic_adjustment\"\ndata_path = experiment_name * \".jld2\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The domain, number of grid points, and other parameters.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"architecture = CPU()      # CPU or GPU?\nLy = 1000kilometers       # north-south extent [m]\nLz = 1kilometers          # depth [m]\nNy = 64                   # grid points in north-south direction\nNz = 16                   # grid points in the vertical\nΔt = 10minute             # time-step\nstop_time = 1days         # length of run\nsave_interval = 0.25days  # save observation every so often\n\nforce_generate_observations = false\nnothing # hide\n\nhorizontal_diffusivity = HorizontalScalarDiffusivity(κ=100)\nvertical_diffusivity = VerticalScalarDiffusivity(κ=1e-2)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The isopycnal skew-symmetric diffusivity closure.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"gerdes_koberle_willebrand_tapering = FluxTapering(1e-2)\ngent_mcwilliams_diffusivity = IsopycnalSkewSymmetricDiffusivity(κ_skew = κ_skew,\n                                                                κ_symmetric = κ_symmetric,\n                                                                slope_limiter = gerdes_koberle_willebrand_tapering)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Generate-synthetic-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Generate synthetic observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"if force_generate_observations || !(isfile(data_path))\n    grid = RectilinearGrid(architecture,\n                           topology = (Flat, Bounded, Bounded),\n                           size = (Ny, Nz),\n                           y = (-Ly/2, Ly/2),\n                           z = (-Lz, 0),\n                           halo = (3, 3))\n\n    closures = (gent_mcwilliams_diffusivity, horizontal_diffusivity, vertical_diffusivity)\n\n    model = HydrostaticFreeSurfaceModel(grid = grid,\n                                        tracers = (:b, :c),\n                                        buoyancy = BuoyancyTracer(),\n                                        coriolis = BetaPlane(latitude=-45),\n                                        closure = closures,\n                                        free_surface = ImplicitFreeSurface())\n\n    @info \"Built $model.\"\n\n    ##### Initial conditions of an unstable buoyancy front\n\n    \"\"\"\n    Linear ramp from 0 to 1 between -Δy/2 and +Δy/2.\n\n    For example:\n\n    y < y₀           => ramp = 0\n    y₀ < y < y₀ + Δy => ramp = y / Δy\n    y > y₀ + Δy      => ramp = 1\n    \"\"\"\n    ramp(y, Δy) = min(max(0, y/Δy + 1/2), 1)\n\n    N² = 4e-6             # [s⁻²] buoyancy frequency / stratification\n    M² = 8e-8             # [s⁻²] horizontal buoyancy gradient\n\n    Δy = 50kilometers     # horizontal extent of the font\n\n    Δc_y = 2Δy            # horizontal extent of initial tracer concentration\n    Δc_z = 50             # [m] vertical extent of initial tracer concentration\n\n    Δb = Δy * M²          # inital buoyancy jump\n\n    bᵢ(x, y, z) = N² * z + Δb * ramp(y, Δy)\n    cᵢ(x, y, z) = exp(-y^2 / 2Δc_y^2) * exp(-(z + Lz/2)^2 / (2Δc_z^2))\n\n    set!(model, b=bᵢ, c=cᵢ)\n\n    simulation = Simulation(model, Δt=Δt, stop_time=stop_time)\n\n    simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),\n                                                          schedule = TimeInterval(save_interval),\n                                                          prefix = experiment_name,\n                                                          array_type = Array{Float64},\n                                                          with_halos = true,\n                                                          force = true)\n\n    run!(simulation)\nend","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Load-truth-data-as-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Load truth data as observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We use here the Transformation functionality to slice up the observation data a bit. In particular, we choose to exclude the 3 grid points on either side of the y dimension, and 3 grid points from the bottom of the domain. Also, we only use the last 3 snapshots of the observations.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We use SpaceIndices and TimeIndices to denote which space-time indices we would like to keep in observations.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"transformation = Transformation(space=SpaceIndices(y=4:Ny-3, z=4:Nz), time=TimeIndices(3:5), normalization=ZScore())\nobservations = SyntheticObservations(data_path; field_names=(:b, :c), transformation)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Calibration-with-Ensemble-Kalman-Inversion","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Ensemble-model","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Ensemble model","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First we set up an ensemble model,","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_size = 20\n\nslice_ensemble_size = SliceEnsembleSize(size=(Ny, Nz), ensemble=ensemble_size)\n\n@show ensemble_grid = RectilinearGrid(architecture,\n                                      size=slice_ensemble_size,\n                                      topology = (Flat, Bounded, Bounded),\n                                      y = (-Ly/2, Ly/2),\n                                      z = (-Lz, 0),\n                                      halo=(3, 3))\n\ngm_ensemble = [deepcopy(gent_mcwilliams_diffusivity) for i = 1:ensemble_size]\nclosures = (gm_ensemble, horizontal_diffusivity, vertical_diffusivity)\n\n@show ensemble_model = HydrostaticFreeSurfaceModel(grid = ensemble_grid,\n                                                   tracers = (:b, :c),\n                                                   buoyancy = BuoyancyTracer(),\n                                                   coriolis = BetaPlane(latitude=-45),\n                                                   closure = closures,\n                                                   free_surface = ImplicitFreeSurface())","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"and then we create an ensemble simulation:","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_simulation = Simulation(ensemble_model; Δt, stop_time)\n\nensemble_simulation","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Free-parameters","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Free parameters","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We construct some prior distributions for our free parameters. We found that it often helps to constrain the prior distributions so that neither very high nor very low values for diffusivities can be drawn out of the distribution.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"priors = (κ_skew = ScaledLogitNormal(bounds=(400.0, 1300.0)),\n          κ_symmetric = ScaledLogitNormal(bounds=(700.0, 1700.0)))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"To visualize the prior distributions we randomly sample out values from then and plot the p.d.f.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using CairoMakie\nusing ParameterEstimocean.Parameters: unconstrained_prior, transform_to_constrained\n\nsamples(prior) = [transform_to_constrained(prior, x) for x in rand(unconstrained_prior(prior), 10000000)]\n\nsamples_κ_skew = samples(priors.κ_skew)\nsamples_κ_symmetric = samples(priors.κ_symmetric)\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"Diffusivities [m² s⁻¹]\", ylabel = \"PDF\")\ndensities = []\npush!(densities, density!(ax, samples_κ_skew))\npush!(densities, density!(ax, samples_κ_symmetric))\nLegend(fig[1, 2], densities, [\"κ_skew\", \"κ_symmetric\"], position = :lb)\n\nsave(\"visualize_prior_diffusivities_baroclinic_adjustment.svg\", fig); nothing # hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#The-inverse-problem","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"The inverse problem","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We can construct the inverse problem y = G(θ) + η. Here, y are the observations and G is the ensemble_model.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Assert-that-G(θ_*)-y","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Assert that G(θ_*)  y","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"As a sanity check we apply the forward_map on the calibration after we initialize all ensemble members with the true parameter values. We then confirm that the output of the forward_map matches the observations to machine precision.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"G = forward_map(calibration, θ★)\ny = observation_map(calibration)\nnothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The forward_map output G is a two-dimensional matrix whose first dimension is the size of the state space. Here, after the transformation we applied to the observations, we have that the state space size is 2 times (N_y - 6) times (N_z - 3) times 3; the 2 comes from the two tracers we used as observations and the 3 comes from only using the last three snapshots of the observations. The second dimension of the forward_map output is the ensemble_size.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"@show size(G) == (2 * (Ny-6) * (Nz-3) * 3, ensemble_size)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Since above we computed G using the true parameters θ_*, all columns of the forward map output should be the same as the observations:","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"mean(G, dims=2) ≈ y","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Next, we construct an EnsembleKalmanInversion (EKI) object,","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"eki = EnsembleKalmanInversion(calibration; pseudo_stepping=ConstantConvergence(0.4))","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"params = iterate!(eki; iterations = 5)\n\n@show params","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Last, we visualize few metrics regarding how the EKI calibration went about.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"θ̅(iteration) = [eki.iteration_summaries[iteration].ensemble_mean...]\nvarθ(iteration) = eki.iteration_summaries[iteration].ensemble_var\n\nweight_distances = [norm(θ̅(iter) - [θ★[1], θ★[2]]) for iter in 1:eki.iteration]\noutput_distances = [norm(forward_map(calibration, θ̅(iter))[:, 1] - y) for iter in 1:eki.iteration]\nensemble_variances = [varθ(iter) for iter in 1:eki.iteration]\n\nf = Figure()\nlines(f[1, 1], 1:eki.iteration, weight_distances, color = :red, linewidth = 2,\n      axis = (title = \"Parameter distance\",\n              xlabel = \"Iteration\",\n              ylabel=\"|θ̅ₙ - θ⋆|\",\n              yscale = log10))\nlines(f[1, 2], 1:eki.iteration, output_distances, color = :blue, linewidth = 2,\n      axis = (title = \"Output distance\",\n              xlabel = \"Iteration\",\n              ylabel=\"|G(θ̅ₙ) - y|\",\n              yscale = log10))\nax3 = Axis(f[2, 1:2], title = \"Parameter convergence\",\n           xlabel = \"Iteration\",\n           ylabel = \"Ensemble variance\",\n           yscale = log10)\n\nfor (i, pname) in enumerate(free_parameters.names)\n    ev = getindex.(ensemble_variances, i)\n    lines!(ax3, 1:eki.iteration, ev / ev[1], label = String(pname), linewidth = 2)\nend\n\naxislegend(ax3, position = :rt)\nsave(\"summary_baroclinic_adjustment.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"f = Figure()\n\naxtop = Axis(f[1, 1])\n\naxmain = Axis(f[2, 1],\n              xlabel = \"κ_skew [m² s⁻¹]\",\n              ylabel = \"κ_symmetric [m² s⁻¹]\")\n\naxright = Axis(f[2, 2])\nscatters = []\nlabels = String[]\n\nfor iteration in [0, 1, 2, 5]\n    # Make parameter matrix\n    parameters = eki.iteration_summaries[iteration].parameters\n    Nensemble = length(parameters)\n    Nparameters = length(first(parameters))\n    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:Nparameters]\n\n    label = iteration == 0 ? \"Initial ensemble\" : \"Iteration $iteration\"\n    push!(labels, label)\n    push!(scatters, scatter!(axmain, parameter_ensemble_matrix))\n    density!(axtop, parameter_ensemble_matrix[:, 1])\n    density!(axright, parameter_ensemble_matrix[:, 2], direction = :y)\nend\n\nvlines!(axmain, [κ_skew], color = :red)\nvlines!(axtop, [κ_skew], color = :red)\n\nhlines!(axmain, [κ_symmetric], color = :red)\nhlines!(axright, [κ_symmetric], color = :red)\n\ncolsize!(f.layout, 1, Fixed(300))\ncolsize!(f.layout, 2, Fixed(200))\n\nrowsize!(f.layout, 1, Fixed(200))\nrowsize!(f.layout, 2, Fixed(300))\n\nLegend(f[1, 2], scatters, labels, position = :lb)\n\nhidedecorations!(axtop, grid = false)\nhidedecorations!(axright, grid = false)\n\nxlims!(axmain, 350, 1350)\nxlims!(axtop, 350, 1350)\nylims!(axmain, 650, 1750)\nylims!(axright, 650, 1750)\nxlims!(axright, 0, 0.015)\nylims!(axtop, 0, 0.015)\n\nsave(\"distributions_baroclinic_adjustment.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"EditURL = \"https://github.com/CliMA/ParameterEstimocean.jl/blob/main/examples/intro_to_observations.jl\"","category":"page"},{"location":"literated/intro_to_observations/#Intro-to-observations","page":"Intro to observations","title":"Intro to observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"This example demonstrates the features of SyntheticObservations when constructed from  \"synthetic observations\" generated by an Oceananigans Simulation.","category":"page"},{"location":"literated/intro_to_observations/#Install-dependencies","page":"Intro to observations","title":"Install dependencies","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"using Pkg\npkg\"add ParameterEstimocean, Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"First we load few things","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"using ParameterEstimocean\nusing Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.TurbulenceClosures: ConvectiveAdjustmentVerticalDiffusivity\nusing CairoMakie","category":"page"},{"location":"literated/intro_to_observations/#Generating-synthetic-observations","page":"Intro to observations","title":"Generating synthetic observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"We define a utility function for constructing synthetic observations,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"default_closure = ConvectiveAdjustmentVerticalDiffusivity(; convective_κz = 1.0,\n                                                            convective_νz = 0.9,\n                                                            background_κz = 1e-4,\n                                                            background_νz = 1e-5)\n\nfunction generate_synthetic_observations(name = \"convective_adjustment\"; Nz = 32, Lz = 64,\n                                         Qᵇ = +1e-8, Qᵘ = -1e-5, f₀ = 1e-4, N² = 1e-6,\n                                         Δt = 10.0, stop_time = 12hours, overwrite=false,\n                                         tracers = :b, closure = default_closure)\n\n    data_path = name * \".jld2\"\n\n    if isfile(data_path)\n        @warn(\"Using existing data at $data_path. \" *\n              \"Please delete this file if you wish to generate new data.\")\n\n        return data_path\n    end\n\n    grid = RectilinearGrid(size=Nz, z=(-Lz, 0), topology=(Flat, Flat, Bounded))\n    u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ))\n    b_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵇ), bottom = GradientBoundaryCondition(N²))\n\n    model = HydrostaticFreeSurfaceModel(; grid, tracers, closure,\n                                          buoyancy = BuoyancyTracer(),\n                                          boundary_conditions = (u=u_bcs, b=b_bcs),\n                                          coriolis = FPlane(f=f₀))\n\n    set!(model, b = (x, y, z) -> N² * z)\n    simulation = Simulation(model; Δt, stop_time)\n    init_with_parameters(file, model) = file[\"parameters\"] = (; Qᵇ, Qᵘ, Δt, N², tracers=keys(model.tracers))\n\n    simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),\n                                                          schedule = TimeInterval(stop_time/3),\n                                                          prefix = name,\n                                                          array_type = Array{Float64},\n                                                          with_halos = true,\n                                                          init = init_with_parameters,\n                                                          force = true)\n\n    run!(simulation)\n\n    return data_path\nend","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"and invoke it:","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"data_path = generate_synthetic_observations()","category":"page"},{"location":"literated/intro_to_observations/#Specifying-observations","page":"Intro to observations","title":"Specifying observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"When synthetic observations are constructed from simulation data, we can select","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"The fields to include via field_names\nWhich data in the time-series to include via the times keyword. This can be used to change the initial condition for a calibration run.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"For example, to build observations with a single field we write,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"single_field_observations = SyntheticObservations(data_path, field_names=:b, transformation=ZScore())","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"To build observations with two fields we write","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"two_field_observations = SyntheticObservations(data_path, field_names=(:u, :b), transformation=ZScore())","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"And to build observations with specified times we write","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"times = single_field_observations.times[2:end]\nspecified_times_observations = SyntheticObservations(data_path, field_names=(:u, :b), transformation=ZScore(), times=times)","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"Notice that in the last case, specified_times_observations.times is missing 0.0.","category":"page"},{"location":"literated/intro_to_observations/#Visualizing-observations","page":"Intro to observations","title":"Visualizing observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"For this we include the initial condition and v velocity component,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"observations = SyntheticObservations(data_path, field_names=(:u, :v, :b), transformation=ZScore())\n\nfig = Figure()\n\nax_b = Axis(fig[1, 1], xlabel = \"Buoyancy [m s⁻²]\", ylabel = \"z [m]\")\nax_u = Axis(fig[1, 2], xlabel = \"Velocities [m s⁻¹]\", ylabel = \"z [m]\")\n\nz = znodes(Center, observations.grid)\n\ncolorcycle = [:black, :red, :blue, :orange, :pink]\n\nfor i = 1:length(observations.times)\n    b_ = observations.field_time_serieses.b[i]\n    u_ = observations.field_time_serieses.u[i]\n    v_ = observations.field_time_serieses.v[i]\n    t_ = observations.times[i]\n\n    label = \"t = \" * prettytime(t_)\n    u_label = i == 1 ? \"u, \" * label : label\n    v_label = i == 1 ? \"v, \" * label : label\n\n    lines!(ax_b, 1e4 * interior(b_)[1, 1, :], z; label, color=colorcycle[i]) # convert units from m s⁻² to 10⁻⁴ m s⁻²\n    lines!(ax_u, interior(u_)[1, 1, :], z; linestyle=:solid, color=colorcycle[i], label=u_label)\n    lines!(ax_u, interior(v_)[1, 1, :], z; linestyle=:dash, color=colorcycle[i], label=v_label)\nend\n\naxislegend(ax_b, position=:rb)\naxislegend(ax_u, position=:lb, merge=true)\n\nsave(\"intro_to_observations.svg\", fig)","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"(Image: )","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"Hint: if using a REPL or notebook, try using Pkg; Pkg.add(\"ElectronDisplay\"); using ElectronDisplay; display(fig) To see the figure in a window.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"EditURL = \"https://github.com/CliMA/ParameterEstimocean.jl/blob/main/examples/exploring_priors.jl\"","category":"page"},{"location":"literated/exploring_priors/#Specifying-and-fine-tuning-prior-distributions","page":"Exploring Prior distributions","title":"Specifying and fine-tuning prior distributions","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"This example shows how to specify priors in ParameterEstimocean and illustrates some of their properties.","category":"page"},{"location":"literated/exploring_priors/#Install-dependencies","page":"Exploring Prior distributions","title":"Install dependencies","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"using Pkg\npkg\"add ParameterEstimocean, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Then we import packages","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"using ParameterEstimocean\nusing CairoMakie\nusing Distributions","category":"page"},{"location":"literated/exploring_priors/#What's-a-prior?","page":"Exploring Prior distributions","title":"What's a prior?","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"A \"prior\" is a probability distribution for an known parameter that represents \"prior knowledge\" of the problem at hand, before we generate new knowledge with a new model-data comparison via ensemble Kalman inversion (EKI).","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"In the (EKI) context, a prior distribution determines (i) the initial distribution of parameter values in the ensemble and (ii) the mapping between physical space where constraints on parameter values are applied, and the \"unconstrained\" space in which the EKI dynamics evolve (and where parameters are assumed normally-distributed).","category":"page"},{"location":"literated/exploring_priors/#Prior-flavors","page":"Exploring Prior distributions","title":"Prior flavors","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"ParameterEstimocean supports three types of prior distributions. The normal prior distribution is provided by Distributions.jl,","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"normal_prior = Normal(0.1, 0.1)","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"For LogNormal priors, we provide a special constructor that takes the mean and standard deviation std of the prior distribution in constrained space:","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"lognormal_prior = lognormal(mean=0.1, std=0.1)","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"lognormal calculates μ and σ for Distributions.Lognormal(μ, σ). Parameters with a Lognormal prior distribution are strictly positive. Finally, the \"scaled\" logit-normal prior,","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"logitnormal_prior = ScaledLogitNormal(bounds=(0, 0.2))","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"can be used to provide strict upper and lower bounds for parameter values.","category":"page"},{"location":"literated/exploring_priors/#Samples","page":"Exploring Prior distributions","title":"Samples","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Sampling the distributions reveals their properties. We define a function to use later, too.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"function visualize_priors(priors; samples = 10^6)\n    fig = Figure()\n    ax = Axis(fig[1, 1:9], xlabel=\"Random samples of priors\", ylabel=\"Density\")\n\n    for (prior, name) in zip(values(priors), keys(priors))\n        density!(ax, rand(prior, samples), label=replace(string(name), \"_\" => \" \"))\n    end\n\n    axislegend(ax)\n\n    return fig, ax\nend\n\nfig, ax = visualize_priors(Dict(\"Normal\" => normal_prior,\n                                \"Log normal\" => lognormal_prior,\n                                \"Scaled logit-normal\" => logitnormal_prior))\n\nxlims!(ax, -0.5, 1.5)\nsave(\"prior_flavors.svg\", fig); nothing # hide","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"(Image: )","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"We note three important features:","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Normal samples can be negative.\nLognormal samples cannot be negative, but can have large positive values.\nScaledLogitNormal samples have compact support, and thus strict upper and lower bounds.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Boundedness is a very useful property of ScaledLogitNormal, so we explore specifying ScaledLogitNormal priors in more detail.","category":"page"},{"location":"literated/exploring_priors/#Fine-tuning-a-ScaledLogitNormal-prior","page":"Exploring Prior distributions","title":"Fine-tuning a ScaledLogitNormal prior","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"We can tune the \"width\" of a ScaledLogitNormal by supplying the standard-deviation σ:","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"logit_priors = Dict(\"Narrow (σ = 0.1)\"                 => ScaledLogitNormal(σ = 0.1),\n                    \"Default (σ = 1)\"                  => ScaledLogitNormal(σ = 1),\n                    \"Weird (σ = 4 with bounds=(0, 1))\" => ScaledLogitNormal(σ = 4))\n\nfig, ax = visualize_priors(logit_priors)\nxlims!(ax, -0.1, 1.1)\nsave(\"logit_normal_widths.svg\", fig); nothing #hide","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"(Image: )","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Smaller standard deviations produce narrower prior distributions. However, weird shapes can result when a standard deviation is specified that's larger than the bounds interval (eg σ > diff(bounds)). In the above example we're using the default bounds = (0, 1).","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Another way to build ScaledLogitNormal prior is to specify a central interval and mass. This allows us to shift the center of mass relative to the bounds (here we use the default bounds=(0, 1)), and provides a slightly safer way to tune a distribution.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"shifted_priors = Dict(\"Shifted left\"  => ScaledLogitNormal(interval=(0.2, 0.3), mass=0.9),\n                      \"Shifted right\" => ScaledLogitNormal(interval=(0.7, 0.8), mass=0.9),\n                      \"Centered\"      => ScaledLogitNormal(interval=(0.2, 0.8), mass=0.6))\n\nfig, ax = visualize_priors(shifted_priors)\nxlims!(ax, -0.1, 1.1)\nsave(\"logit_normal_shifting.svg\", fig); nothing #hide","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"(Image: )","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"The \"Centered\" case uses a mass that's proportional to the relative width spanned by interval (eg mass = diff(interval) / diff(bounds)) to produce a nearly uniform distribution within the bounds.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ParameterEstimocean.jl-Documentation","page":"Home","title":"ParameterEstimocean.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ParameterEstimocean provides a framework to calibrate turbulence closure parametrizations for ocean models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ParameterEstimocean.jl is developed by the Climate Modeling Alliance and heroic external collaborators.","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for ParameterEstimocean.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"library/public/#ParameterEstimocean","page":"Public","title":"ParameterEstimocean","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ParameterEstimocean]\nPrivate = false","category":"page"},{"location":"library/public/#Transformations","page":"Public","title":"Transformations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ParameterEstimocean.Transformations]\nPrivate = false","category":"page"},{"location":"library/public/#ParameterEstimocean.Transformations.Transformation-Tuple{}","page":"Public","title":"ParameterEstimocean.Transformations.Transformation","text":"Transformation(; time=nothing, space=nothing, normalization=nothing)\n\nReturn a transformation that is applied on the observation. Examples include slicing the data or multiplying with weight factors to make the loss function putting more  weight in particular regions of the domain or particular times. Also, we can denote a normalization procedure applied to the data after the space- and time- transformations.\n\nSlicing is prescribed as SpaceIndices and TimeIndices. For example\n\nTransformation(time = TimeIndices(4:10))\n\nwill only keep time instances 4 to 10 from the observations. Similarly,\n\nTransformation(space = SpaceIndices(x=:, y=1:10, z=2:2:20))\n\nwill not affect the x dimension of the data, but will slice the observations in y and z as prescribed.\n\nKeyword Arguments\n\ntime: The time transformation either as a TimeIndices or as an AbstractVector of weights of same size as observations.times. If nothing is given, then, by default, the transformation ignores the first snapshot (initial state).\nspace: The space trasformation either as a SpaceIndices or as an AbstractArray of weights of same size as a snapshot of the observations.\nnormalization: The normalization that is applied to the data after space and time  transformations have been applied first.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ParameterEstimocean.Transformations.ZScore-Tuple{Any}","page":"Public","title":"ParameterEstimocean.Transformations.ZScore","text":"ZScore(field_time_series::FieldTimeSeries)\n\nReturn the ZScore normalization of a FieldTimeSeries after computing its mean and its variance.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Observations","page":"Public","title":"Observations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ParameterEstimocean.Observations]\nPrivate = false","category":"page"},{"location":"library/public/#ParameterEstimocean.Observations.SyntheticObservations","page":"Public","title":"ParameterEstimocean.Observations.SyntheticObservations","text":"SyntheticObservations(path;\n                      field_names,\n                      forward_map_names = field_names,\n                      transformation = Transformation()),\n                      times = nothing,\n                      field_time_serieses = nothing,\n                      regrid = nothing)\n\nReturn a time series of synthetic observations generated by Oceananigans.jl's simulations gridded as Oceananigans.jl fields.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Ensemble-Simulations","page":"Public","title":"Ensemble Simulations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ParameterEstimocean.EnsembleSimulations]\nPrivate = false","category":"page"},{"location":"library/public/#Parameters","page":"Public","title":"Parameters","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ParameterEstimocean.Parameters]\nPrivate = false","category":"page"},{"location":"library/public/#ParameterEstimocean.Parameters.FreeParameters","page":"Public","title":"ParameterEstimocean.Parameters.FreeParameters","text":"struct FreeParameters{N, P}\n\nA container for free parameters that includes the parameter names and their corresponding prior distributions.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#ParameterEstimocean.Parameters.FreeParameters-Tuple{Any}","page":"Public","title":"ParameterEstimocean.Parameters.FreeParameters","text":"FreeParameters(priors; names = Symbol.(keys(priors)))\n\nReturn named FreeParameters with priors. Free parameter names are inferred from the keys of priors if not provided.\n\nExample\n\njulia> using Distributions, ParameterEstimocean\n\njulia> priors = (ν = Normal(1e-4, 1e-5), κ = Normal(1e-3, 1e-5))\n(ν = Normal{Float64}(μ=0.0001, σ=1.0e-5), κ = Normal{Float64}(μ=0.001, σ=1.0e-5))\n\njulia> free_parameters = FreeParameters(priors)\nFreeParameters with 2 parameters\n├── names: (:ν, :κ)\n└── priors: Dict{Symbol, Any}\n    ├── ν => Normal{Float64}(μ=0.0001, σ=1.0e-5)\n    └── κ => Normal{Float64}(μ=0.001, σ=1.0e-5)\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ParameterEstimocean.Parameters.ScaledLogitNormal","page":"Public","title":"ParameterEstimocean.Parameters.ScaledLogitNormal","text":"ScaledLogitNormal([FT=Float64;] bounds=(0, 1), mass=0.5, interval=nothing)\n\nReturn a ScaledLogitNormal distribution with compact support within bounds.\n\ninterval is an optional 2-element tuple or Array. When specified, the parameters μ and σ of the underlying Normal distribution are calculated so that mass fraction of the probability density lies within interval.\n\nIf interval is not specified, then μ=0 and σ=1 by default.\n\nNotes\n\nScaledLogitNormal is a four-parameter distribution generated by the transformation\n\nY = L + (U - L)  1 + exp(X)\n\nof the normally-distributed variate X  𝒩(μ σ). The four parameters governing the distribution of Y are thus\n\nL:  lower bound (0 for the LogitNormal distribution)\nU:  upper bound (1 for the LogitNormal distribution)\nμ:  mean of the underlying Normal distribution\nσ²: variance of the underlying Normal distribution\n\n\n\n\n\n","category":"type"},{"location":"library/public/#ParameterEstimocean.Parameters.lognormal-Tuple{}","page":"Public","title":"ParameterEstimocean.Parameters.lognormal","text":"lognormal(; mean, std)\n\nReturn Lognormal distribution parameterized by  the distribution mean and standard deviation std.\n\nNotes\n\nA variate X is LogNormal distributed if\n\nlog(X)  𝒩(μ σ²) \n\nwhere 𝒩(μ σ²) is the Normal distribution with mean μ and variance σ².\n\nThe mean and variance s² (where s is the standard deviation or std) are related to the parameters μ and σ² via\n\n m = exp(μ + σ²  2)\n\ns² = exp(σ²) - 1 m²\n\nThese formula allow us to calculate μ and σ given m and s², since rearranging the formula for s² gives\n\nexp(σ²) = m²  s² + 1\n\nwhich then yields\n\nσ = sqrtlog(m²  s² + 1)\n\nWe then find that\n\nμ = log(m) - σ²  2 \n\nSee also wikipedia.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Inverse-Problems","page":"Public","title":"Inverse Problems","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ParameterEstimocean.InverseProblems]\nPrivate = false","category":"page"},{"location":"library/public/#ParameterEstimocean.InverseProblems.ConcatenatedOutputMap","page":"Public","title":"ParameterEstimocean.InverseProblems.ConcatenatedOutputMap","text":"struct ConcatenatedOutputMap end\n\nForward map transformation of simulation output to the concatenated vectors of the simulation output.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#ParameterEstimocean.InverseProblems.InverseProblem-Tuple{Any, Any, Any}","page":"Public","title":"ParameterEstimocean.InverseProblems.InverseProblem","text":"InverseProblem(observations,\n               simulation,\n               free_parameters;\n               output_map = ConcatenatedOutputMap(),\n               time_series_collector = nothing)\n\nReturn an InverseProblem.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ParameterEstimocean.InverseProblems.forward_map-Tuple{Any, Any}","page":"Public","title":"ParameterEstimocean.InverseProblems.forward_map","text":"forward_map(ip, parameters)\n\nRun ip.simulation forward with parameters and return the data, transformed into an array format expected by EnsembleKalmanProcesses.jl.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ParameterEstimocean.InverseProblems.forward_run!-Tuple{InverseProblem, Any}","page":"Public","title":"ParameterEstimocean.InverseProblems.forward_run!","text":"forward_run!(ip, parameters)\n\nInitialize ip.simulation with parameters and run it forward. Output is stored in ip.time_series_collector.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ParameterEstimocean.InverseProblems.observation_map-Tuple{InverseProblem}","page":"Public","title":"ParameterEstimocean.InverseProblems.observation_map","text":"observation_map(ip::InverseProblem)\n\nTransform and return ip.observations appropriate for ip.output_map. \n\n\n\n\n\n","category":"method"},{"location":"library/public/#ParameterEstimocean.InverseProblems.observation_map_variance_across_time-Tuple{ConcatenatedOutputMap, SyntheticObservations}","page":"Public","title":"ParameterEstimocean.InverseProblems.observation_map_variance_across_time","text":"observation_map_variance_across_time(map::ConcatenatedOutputMap, observation::SyntheticObservations)\n\nReturn an array of size (Nensemble, Ny * Nz * Nfields, Ny * Nz * Nfields) that stores the covariance of each element of the observation map measured across time, for each ensemble member, where Nensemble is the ensemble size, Ny is either the number of grid elements in y or the batch size, Nz is the number of grid elements in the vertical, and Nfields is the number of fields in observation.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#EnsembleKalmanInversions","page":"Public","title":"EnsembleKalmanInversions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ParameterEstimocean.EnsembleKalmanInversions]\nPrivate = false","category":"page"},{"location":"library/public/#ParameterEstimocean.EnsembleKalmanInversions.EnsembleKalmanInversion-Tuple{Any}","page":"Public","title":"ParameterEstimocean.EnsembleKalmanInversions.EnsembleKalmanInversion","text":"EnsembleKalmanInversion(inverse_problem;\n                        noise_covariance = 1,\n                        pseudo_stepping = nothing,\n                        resampler = Resampler(),\n                        unconstrained_parameters = nothing,\n                        forward_map_output = nothing,\n                        process = Inversion())\n\nReturn an object that finds local minima of the inverse problem:\n\ny = G(θ) + η\n\nfor the parameters θ, where y is a vector of observations (often normalized), G(θ) is a forward map that predicts the observations, and η  𝒩(0 Γ_y) is zero-mean random noise with a noise_covariance matrix Γ_y representing uncertainty in the observations.\n\nThe \"forward map output\" G is model output mapped to the space of inverse_problem.observations.\n\n(For more details on the Ensemble Kalman Inversion algorithm refer to the EnsembleKalmanProcesses.jl Documentation.)\n\nArguments\n\ninverse_problem (InverseProblem): Represents an inverse problem representing the comparison between                                       synthetic observations generated by                                       Oceananigans.jl                                       and model predictions, also generated by Oceananigans.jl.\nnoise_covariance (Number or AbstractMatrix): Covariance matrix representing observational uncertainty.                                                    noise_covariance::Number is converted to a scaled identity matrix.\npseudo_stepping: The pseudo time-stepping scheme for stepping EKI forward.\nresampler: controls particle resampling procedure. See Resampler.\nprocess: The Ensemble Kalman process. Default: `Inversion().\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ParameterEstimocean.EnsembleKalmanInversions.iterate!-Tuple{EnsembleKalmanInversion}","page":"Public","title":"ParameterEstimocean.EnsembleKalmanInversions.iterate!","text":"iterate!(eki::EnsembleKalmanInversion;\n         iterations = 1,\n         pseudo_stepping = eki.pseudo_stepping,\n         show_progress = true)\n\nIterate the ensemble Kalman inversion problem eki forward by iterations.\n\nKeyword arguments\n\niterations (Int): Number of iterations to run (default: 1)\npseudostepping (Float64): Ensemble convergence rate for adaptive time-stepping.                             (Default: `eki.pseudostepping`)\npseudoΔt (Float64): Pseudo time-step. When `convegencerate` is specified,                      this is an initial guess for finding an adaptive time-step.                      (Default: 1.0)\n\nReturn\n\nbest_parameters: the ensemble mean of all parameter values after the last iteration.\n\n\n\n\n\n","category":"method"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/ParameterEstimocean.jl/blob/main/examples/perfect_convective_adjustment_calibration.jl\"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Perfect-convective-adjustment-calibration-with-Ensemble-Kalman-Inversion","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"This example calibrates a convective adjustment model in the \"perfect model context\". In this context, synthetic observations are generated by a convective adjustment model with \"true\" parameters. The true parameters are then \"rediscovered\" by calibrating the model to match the synthetic observations.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"We use the discrepency between observed and modeled buoyancy b to calibrate the convective adjustment model. The calibration problem is solved by Ensemble Kalman Inversion. For more information about Ensemble Kalman Inversion, see the EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Install-dependencies","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"using Pkg\npkg\"add ParameterEstimocean, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"using ParameterEstimocean, LinearAlgebra, CairoMakie","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"We reuse some some code from a previous example to generate observations,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"examples_path = joinpath(pathof(ParameterEstimocean), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_inverse_problems.jl\"))\n\ndata_path = generate_synthetic_observations()\nobservations = SyntheticObservations(data_path, field_names=:b, transformation=ZScore())","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"and an ensemble_simulation,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_simulation, closure★ = build_ensemble_simulation(observations; Nensemble=50)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The handy utility function build_ensemble_simulation also tells us the optimal parameters that were used when generating the synthetic observations:","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"@show θ★ = (convective_κz = closure★.convective_κz, background_κz = closure★.background_κz)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#The-InverseProblem","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"The InverseProblem","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"To build an inverse problem we first define free parameters. Here we calibrate convective_κz and background_κz, using log-normal priors to prevent the parameters from becoming negative:","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"priors = (convective_κz = lognormal(mean=0.3, std=0.5),\n          background_κz = lognormal(mean=2.5e-4, std=2.5e-5))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The InverseProblem is then constructed from observations, ensemble_simulation, and free_parameters,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"For more information about the above steps, see Intro to observations and Intro to InverseProblem.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Ensemble-Kalman-Inversion","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"Next, we construct an EnsembleKalmanInversion (EKI) object,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The calibration is done here using Ensemble Kalman Inversion. For more information about the algorithm refer to EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"eki = EnsembleKalmanInversion(calibration; pseudo_stepping = ConstantConvergence(0.5))","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"iterate!(eki; iterations = 10)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"Last, we visualize the outputs of EKI calibration.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"θ̅(iteration) = [eki.iteration_summaries[iteration].ensemble_mean...]\nvarθ(iteration) = eki.iteration_summaries[iteration].ensemble_var\n\nweight_distances = [norm(θ̅(iter) - [θ★[1], θ★[2]]) for iter in 0:eki.iteration]\noutput_distances = [norm(forward_map(calibration, θ̅(iter))[:, 1] - y) for iter in 0:eki.iteration]\nensemble_variances = [varθ(iter) for iter in 0:eki.iteration]\n\nf = Figure()\n\nlines(f[1, 1], 0:eki.iteration, weight_distances, color = :red, linewidth = 2,\n      axis = (title = \"Parameter distance\",\n              xlabel = \"Iteration\",\n              ylabel = \"|θ̅ₙ - θ★|\"))\n\nlines(f[1, 2], 0:eki.iteration, output_distances, color = :blue, linewidth = 2,\n      axis = (title = \"Output distance\",\n              xlabel = \"Iteration\",\n              ylabel = \"|G(θ̅ₙ) - y|\"))\n\nax3 = Axis(f[2, 1:2],\n           title = \"Parameter convergence\",\n           xlabel = \"Iteration\",\n           ylabel = \"Ensemble variance\",\n           yscale = log10)\n\nfor (i, pname) in enumerate(free_parameters.names)\n    ev = getindex.(ensemble_variances, i)\n    lines!(ax3, 0:eki.iteration, ev / ev[1], label = String(pname), linewidth = 2)\nend\n\naxislegend(ax3, position = :rt)\n\nsave(\"summary_convective_adjustment_eki.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"fig = Figure()\n\naxtop = Axis(fig[1, 1])\naxmain = Axis(fig[2, 1], xlabel = \"convective_κz [m² s⁻¹]\",\n                       ylabel = \"background_κz [m² s⁻¹]\")\n\naxright = Axis(fig[2, 2])\nscatters = []\nlabels = String[]\n\nfor iteration in [0, 1, 2, 10]\n    # Make parameter matrix\n    parameters = eki.iteration_summaries[iteration].parameters\n    Nensemble = length(parameters)\n    Nparameters = length(first(parameters))\n    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:Nparameters]\n\n    label = iteration == 0 ? \"Initial ensemble\" : \"Iteration $iteration\"\n    push!(labels, label)\n    push!(scatters, scatter!(axmain, parameter_ensemble_matrix))\n    density!(axtop, parameter_ensemble_matrix[:, 1])\n    density!(axright, parameter_ensemble_matrix[:, 2], direction = :y)\nend\n\nvlines!(axmain, [θ★.convective_κz], color = :red)\nvlines!(axtop, [θ★.convective_κz], color = :red)\n\nhlines!(axmain, [θ★.background_κz], color = :red)\nhlines!(axright, [θ★.background_κz], color = :red)\n\ncolsize!(fig.layout, 1, Fixed(300))\ncolsize!(fig.layout, 2, Fixed(200))\nrowsize!(fig.layout, 1, Fixed(200))\nrowsize!(fig.layout, 2, Fixed(300))\n\nLegend(fig[1, 2], scatters, labels, position = :lb)\n\nhidedecorations!(axtop, grid = false)\nhidedecorations!(axright, grid = false)\n\nxlims!(axmain, -0.25, 3.2)\nxlims!(axtop, -0.25, 3.2)\nylims!(axmain, 5e-5, 35e-5)\nylims!(axright, 5e-5, 35e-5)\n\nsave(\"distributions_convective_adjustment_eki.svg\", fig); nothing #hide","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"}]
}
