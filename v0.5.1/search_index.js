var documenterSearchIndex = {"docs":
[{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/perfect_catke_calibration.jl\"","category":"page"},{"location":"literated/perfect_catke_calibration/#Perfect-CAKTE-calibration-with-Ensemble-Kalman-Inversion","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_catke_calibration/#Install-dependencies","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"using OceanTurbulenceParameterEstimation, LinearAlgebra, CairoMakie\nusing Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities: CATKEVerticalDiffusivity, MixingLength, SurfaceTKEFlux","category":"page"},{"location":"literated/perfect_catke_calibration/#Perfect-observations-of-CATKE-driven-mixing","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect observations of CATKE-driven mixing","text":"","category":"section"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Our first task is to generate synthetic observations, using a one-dimensional model driven by surface fluxes and with turbulent mixing parameterized by CATKE. We use a simplified CATKE with no stability function (by setting Cᴷuʳ = Cᴷcʳ = Cᴷeʳ = 0) and \"reasonable\", but unrealistic parameters. We will only attempt to calibrate a subset of the parameters that we set to generate the observations.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"# Load utilities\nexamples_path = joinpath(pathof(OceanTurbulenceParameterEstimation), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_inverse_problems.jl\"))\n\nmixing_length = MixingLength(Cᴬu  = 0.1,\n                             Cᴬc  = 0.5,\n                             Cᴬe  = 0.1,\n                             Cᴷu⁻ = 0.1,\n                             Cᴷc⁻ = 0.1,\n                             Cᴷe⁻ = 0.1,\n                             Cᴷuʳ = 0.0,\n                             Cᴷcʳ = 0.0,\n                             Cᴷeʳ = 0.0)\n\ncatke = CATKEVerticalDiffusivity(mixing_length=mixing_length)\n\n# Specify both wind mixing and convection:\ndata_path = generate_synthetic_observations(\"catke\",\n                                            closure = catke,\n                                            tracers = (:b, :e),\n                                            Nz = 32,\n                                            Lz = 64,\n                                            Δt = 10.0,\n                                            stop_time = 12hours,\n                                            overwrite = true,\n                                            Qᵘ = -1e-4,\n                                            Qᵇ = 1e-8,\n                                            N² = 1e-5)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Next, we load and inspect the observations to make sure they're sensible:","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"observations = SyntheticObservations(data_path, field_names=(:u, :v, :b, :e), normalization=ZScore())\n\nfig = Figure()\n\nax_b = Axis(fig[1, 1], xlabel = \"Buoyancy\\n[10⁻⁴ m s⁻²]\", ylabel = \"z [m]\")\nax_u = Axis(fig[1, 2], xlabel = \"Velocities\\n[cm s⁻¹]\")\nax_e = Axis(fig[1, 3], xlabel = \"Turbulent kinetic energy\\n[10⁻⁴ m² s⁻²]\")\n\nz = znodes(Center, observations.grid)\n\ncolorcycle = [:black, :red, :blue, :orange, :pink]\n\nfor i = 1:length(observations.times)\n    b = observations.field_time_serieses.b[i]\n    e = observations.field_time_serieses.e[i]\n    u = observations.field_time_serieses.u[i]\n    v = observations.field_time_serieses.v[i]\n    t = observations.times[i]\n\n    label = \"t = \" * prettytime(t)\n    u_label = i == 1 ? \"u, \" * label : label\n    v_label = i == 1 ? \"v, \" * label : label\n\n    lines!(ax_b, 1e4 * interior(b)[1, 1, :], z; label, color=colorcycle[i]) # convert units m s⁻² -> 10⁻⁴ m s⁻²\n    lines!(ax_u, 1e2 * interior(u)[1, 1, :], z; linestyle=:solid, color=colorcycle[i], label=u_label) # convert units m s⁻¹ -> cm s⁻¹\n    lines!(ax_u, 1e2 * interior(v)[1, 1, :], z; linestyle=:dash, color=colorcycle[i], label=v_label) # convert units m s⁻¹ -> cm s⁻¹\n    lines!(ax_e, 1e4 * interior(e)[1, 1, :], z; label, color=colorcycle[i]) # convert units m² s⁻² -> 10⁻⁴ m² s⁻²\nend\n\naxislegend(ax_b, position=:rb)\naxislegend(ax_u, position=:lb, merge=true)\naxislegend(ax_e, position=:rb)\n\n##display(fig)\n\nsave(\"synthetic_catke_observations.svg\", fig); nothing # hide","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Well, that looks like a boundary layer, in some respects.","category":"page"},{"location":"literated/perfect_catke_calibration/#Calibration","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Calibration","text":"","category":"section"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Next, we build a simulation of an ensemble of column models to calibrate CATKE using Ensemble Kalman Inversion.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"architecture = CPU()\nensemble_simulation, closure★ = build_ensemble_simulation(observations, architecture; Nensemble=50)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"We choose to calibrate a subset of the CATKE parameters,","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"priors = (Cᴬu = lognormal_with_mean_std(0.05, 0.01),\n          Cᴬc = lognormal_with_mean_std(0.6, 0.1),\n          Cᴬe = lognormal_with_mean_std(0.2, 0.04))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"The handy utility function build_ensemble_simulation also tells us the optimal parameters that were used when generating the synthetic observations:","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"@show θ★ = (Cᴬu = closure★.mixing_length.Cᴬu,\n            Cᴬc = closure★.mixing_length.Cᴬc,\n            Cᴬe = closure★.mixing_length.Cᴬe)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"We construct the InverseProblem from observations, ensemble_simulation, and free_parameters,","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"We can check that the first ensemble member of the mapped output, which was run with the \"true\" parameters, is identical to the mapped observations:","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"G = forward_map(calibration, θ★)\ny = observation_map(calibration)\n\n@show G[:, 1] ≈ y","category":"page"},{"location":"literated/perfect_catke_calibration/#Ensemble-Kalman-Inversion","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Next, we construct an EnsembleKalmanInversion (EKI) object,","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"The calibration is done here using Ensemble Kalman Inversion. For more information about the algorithm refer to EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"noise_variance = (observation_map_variance_across_time(calibration)[1, :, 1] .+ 1) .* 1e-3\n\neki = EnsembleKalmanInversion(calibration; noise_covariance = Matrix(Diagonal(noise_variance)))","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"iterate!(eki; iterations = 20)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Last, we visualize the outputs of EKI calibration.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"# Convert everything to a vector\noptimal_θ = collect(values(θ★))\nensemble_mean_θ = map(summary -> collect(values(summary.ensemble_mean)), eki.iteration_summaries)\nθ_variances = map(summary -> collect(values(summary.ensemble_var)), eki.iteration_summaries)\n\nnames = keys(θ★)\nabsolute_error = NamedTuple(name => map(θ -> θ[p] - θ★[p], ensemble_mean_θ) for (p, name) in enumerate(names))\nrelative_error = NamedTuple(name => abs.(absolute_error[name]) ./ θ★[name] for name in names)\n\noutput_distances = map(θ -> norm(forward_map(calibration, θ)[:, 1:1] - y), ensemble_mean_θ)\n\nfig = Figure()\n\nax_error = Axis(fig[1, 1], title = \"Parameter distance\", xlabel = \"Iteration\", ylabel = \"|⟨θₙ⟩ - θ★| / θ★\")\n\nfor name in names\n    lines!(ax_error, 0:eki.iteration, parent(relative_error[name]), linewidth=2, label=string(name))\nend\n\naxislegend(ax_error, position=:rt)\n\nlines(fig[1, 2], 0:eki.iteration, parent(output_distances), color = :blue, linewidth = 2,\n      axis = (title = \"Output distance\", xlabel = \"Iteration\", ylabel = \"|G(⟨θₙ⟩) - y|\"))\n\nax3 = Axis(fig[2, 1:2], title = \"Parameter convergence\", xlabel = \"Iteration\",\n           ylabel = \"Relative change ensemble variance\", yscale = log10)\n\nfor (p, name) in enumerate(free_parameters.names)\n    θp_variances = [θ_variances[iter][p] for iter = 0:eki.iteration]\n    lines!(ax3, 0:eki.iteration, parent(θp_variances / θp_variances[1]), label = String(name), linewidth = 2)\nend\n\naxislegend(ax3, position = :rt)\n\n##display(fig)\n\nsave(\"perfect_catke_calibration_summary.svg\", fig); nothing #hide","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"final_mean_θ = eki.iteration_summaries[end].ensemble_mean\nforward_run!(calibration, [θ★, final_mean_θ])\n\ntime_series_collector = calibration.time_series_collector\ntimes = time_series_collector.times\n\n# Extract last save point and plot each solution component\nNt = length(times)\n\nb = time_series_collector.field_time_serieses.b[Nt]\ne = time_series_collector.field_time_serieses.e[Nt]\nu = time_series_collector.field_time_serieses.u[Nt]\nv = time_series_collector.field_time_serieses.v[Nt]\n\nt = times[Nt]\nz = znodes(b)\n\n# The ensemble varies along the first, or `x`-dimension:\nb★ = 1e4 * interior(b)[1, 1, :]  # convert units m s⁻² -> 10⁻⁴ m s⁻²\nb¹ = 1e4 * interior(b)[2, 1, :]  # convert units m s⁻² -> 10⁻⁴ m s⁻²\n\ne★ = 1e4 * interior(e)[1, 1, :]  # convert units m² s⁻² -> 10⁻⁴ m² s⁻²\ne¹ = 1e4 * interior(e)[2, 1, :]  # convert units m² s⁻² -> 10⁻⁴ m² s⁻²\n\nu★ = 1e2 * interior(u)[1, 1, :]  # convert units m s⁻¹ -> cm s⁻¹\nu¹ = 1e2 * interior(u)[2, 1, :]  # convert units m s⁻¹ -> cm s⁻¹\n\nv★ = 1e2 * interior(v)[1, 1, :]  # convert units m s⁻¹ -> cm s⁻¹\nv¹ = 1e2 * interior(v)[2, 1, :]  # convert units m s⁻¹ -> cm s⁻¹\n\nfig = Figure()\n\nax = Axis(fig[1, 1], xlabel = \"Buoyancy\\n[10⁻⁴ m s⁻²]\", ylabel = \"z [m]\")\nb★_label = \"true b at \" * prettytime(t)\nb¹_label = \"b with ⟨θ⟩\"\nlines!(ax, b★, z; label=b★_label, linewidth=3)\nlines!(ax, b¹, z; label=b¹_label, linewidth=2)\naxislegend(ax, position=:lb)\n\nax = Axis(fig[1, 2], xlabel = \"Turbulent kinetic energy\\n[10⁻⁴ m² s⁻²]\")\ne★_label = \"true e at \" * prettytime(t)\ne¹_label = \"e with ⟨θ⟩\"\nlines!(ax, e★, z; label=e★_label, linewidth=3)\nlines!(ax, e¹, z; label=e¹_label, linewidth=2)\naxislegend(ax, position=:lb)\n\nax = Axis(fig[1, 3], xlabel = \"Velocities\\n[cm s⁻¹]\")\nu★_label = \"true u at \" * prettytime(t)\nu¹_label = \"u with ⟨θ⟩\"\nv★_label = \"true v\"\nv¹_label = \"v with ⟨θ⟩\"\nlines!(ax, u★, z; label=u★_label, linewidth=3)\nlines!(ax, u¹, z; label=u¹_label, linewidth=2)\nlines!(ax, v★, z; label=v★_label, linestyle=:dash, linewidth=3)\nlines!(ax, v¹, z; label=v¹_label, linestyle=:dash, linewidth=2)\naxislegend(ax, position=:lb)\n\nsave(\"perfect_catke_calibration_particle_realizations.svg\", fig); nothing # hide","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"##display(fig)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"fig = Figure()\n\nax1 = Axis(fig[1, 1])\nax2 = Axis(fig[2, 1], xlabel = \"Cᴬu [m² s⁻¹]\", ylabel = \"Cᴬc [m² s⁻¹]\")\nax3 = Axis(fig[2, 2])\nscatters = []\nlabels = String[]\n\nfor iteration in [0, 2, 10, 20]\n    # Make parameter matrix\n    parameters = eki.iteration_summaries[iteration].parameters\n    Nensemble = length(parameters)\n    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:2]\n\n    label = iteration == 0 ? \"Initial ensemble\" : \"Iteration $iteration\"\n    push!(labels, label)\n    push!(scatters, scatter!(ax2, parameter_ensemble_matrix))\n    density!(ax1, parameter_ensemble_matrix[:, 1])\n    density!(ax3, parameter_ensemble_matrix[:, 2], direction = :y)\nend\n\nvlines!(ax1, [θ★.Cᴬu], color = :red)\nvlines!(ax2, [θ★.Cᴬu], color = :red)\nhlines!(ax2, [θ★.Cᴬc], color = :red)\nhlines!(ax3, [θ★.Cᴬc], color = :red)\n\ncolsize!(fig.layout, 1, Fixed(300))\ncolsize!(fig.layout, 2, Fixed(200))\nrowsize!(fig.layout, 1, Fixed(200))\nrowsize!(fig.layout, 2, Fixed(300))\n\nLegend(fig[1, 2], scatters, labels, position = :lb)\n\nhidedecorations!(ax1, grid = false)\nhidedecorations!(ax3, grid = false)\n\nxlims!(ax1, 0.025, 0.125)\nxlims!(ax2, 0.025, 0.125)\nylims!(ax2, 0.35, 0.9)\nylims!(ax3, 0.35, 0.9)\n\n##display(fig)\n\nsave(\"perfect_catke_calibration_parameter_distributions.svg\", fig); nothing # hide","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Hint: if using a REPL or notebook, try using Pkg; Pkg.add(\"ElectronDisplay\"); using ElectronDisplay; display(fig) To see the figure in a window.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation Instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"You can install the latest version of OceanTurbulenceParameterEstimation.jl via the built-in package manager (by pressing ] in the Julia REPL command prompt) to add the package and also to  instantiate/build all the required dependencies","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"julia>]\n(v1.6) pkg> add https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl\n(v1.6) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"We recommend installing OceanTurbulenceParameterEstimation.jl with the built-in Julia package manager, because this installs a stable, tagged release. You can update OceanTurbulenceParameterEstimation.jl again via the package manager by typing","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"(v1.6) pkg> update OceanTurbulenceParameterEstimation","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/intro_to_inverse_problems.jl\"","category":"page"},{"location":"literated/intro_to_inverse_problems/#Intro-to-InverseProblem","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"This example illustrates the construction of an \"ensemble simulation\" that can evaluate an ensemble of column models given an ensemble of free parameter sets. The example then builds an InverseProblem from observations, an ensemble simulation, and a set of free parameters, and illustrates its basic usage.","category":"page"},{"location":"literated/intro_to_inverse_problems/#Install-dependencies","page":"Intro to InverseProblem","title":"Install dependencies","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"First we load few things","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"using OceanTurbulenceParameterEstimation\n\nusing Oceananigans\nusing Oceananigans.Architectures: arch_array\nusing Oceananigans.Units\nusing Oceananigans.Models.HydrostaticFreeSurfaceModels: ColumnEnsembleSize\nusing Oceananigans.TurbulenceClosures: ConvectiveAdjustmentVerticalDiffusivity\n\nusing CairoMakie\nusing Distributions\nusing JLD2","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"We reuse some utilities from a previous example to build observations:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"examples_path = joinpath(pathof(OceanTurbulenceParameterEstimation), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_observations.jl\"))\ndata_path = generate_synthetic_observations()\nobservations = SyntheticObservations(data_path, field_names=:b, normalization=ZScore())","category":"page"},{"location":"literated/intro_to_inverse_problems/#Building-an-\"ensemble-simulation\"","page":"Intro to InverseProblem","title":"Building an \"ensemble simulation\"","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"Our next task is to construct a parameterized Oceananigans.Simulation that generates the \"foward map\" for an ensemble of free parameter sets. To generate an ensemble of column model model outputs efficiently, we construct one 3D Oceananigans.Simulation consisting of Nx by Ny independent column models.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"The calibration problem then uses the ensemble simulation to find optimal parameters by minimizing the discrepency between the observations and the forward map.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"\"\"\"\n    extract_perfect_parameters(observations, Nensemble)\n\nExtract parameters from a batch of \"perfect\" observations.\n\"\"\"\nfunction extract_perfect_parameters(observations, Nensemble)\n    Nbatch = length(observations)\n    Qᵘ, Qᵇ, N², f = [zeros(Nensemble, Nbatch) for i = 1:4]\n\n    Nz = first(observations).grid.Nz\n    Hz = first(observations).grid.Hz\n    Lz = first(observations).grid.Lz\n    Δt = first(observations).metadata.parameters.Δt\n\n    for (j, obs) in enumerate(observations)\n        Qᵘ[:, j] .= obs.metadata.parameters.Qᵘ\n        Qᵇ[:, j] .= obs.metadata.parameters.Qᵇ\n        N²[:, j] .= obs.metadata.parameters.N²\n        f[:, j] .= obs.metadata.coriolis.f\n    end\n\n    file = jldopen(first(observations).path)\n    closure = file[\"serialized/closure\"]\n    close(file)\n\n    return Qᵘ, Qᵇ, N², f, Δt, Lz, Nz, Hz, closure\nend\n\n\"\"\"\n    build_ensemble_simulation(observations, arch=CPU(); Nensemble=1)\n\nReturns an `Oceananigans.Simulation` representing an `Nensemble × 1`\nensemble of column models designed to reproduce `observations`.\n\"\"\"\nfunction build_ensemble_simulation(observations, arch=CPU(); Nensemble=1)\n\n    observations isa Vector || (observations = [observations]) # Singleton batch\n    Nbatch = length(observations)\n\n    Qᵘ, Qᵇ, N², f, Δt, Lz, Nz, Hz, closure = extract_perfect_parameters(observations, Nensemble)\n\n    column_ensemble_size = ColumnEnsembleSize(Nz=Nz, ensemble=(Nensemble, Nbatch), Hz=Hz)\n    ensemble_grid = RectilinearGrid(arch, size = column_ensemble_size, topology = (Flat, Flat, Bounded), z = (-Lz, 0))\n\n    coriolis_ensemble = arch_array(arch, [FPlane(f=f[i, j]) for i = 1:Nensemble, j=1:Nbatch])\n    closure_ensemble = arch_array(arch, [deepcopy(closure) for i = 1:Nensemble, j=1:Nbatch])\n\n    Qᵘ, Qᵇ, N² = Tuple(arch_array(arch, p) for p in (Qᵘ, Qᵇ, N²))\n\n    u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ))\n    b_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵇ), bottom = GradientBoundaryCondition(N²))\n\n    tracers = first(observations).metadata.parameters.tracers\n\n    ensemble_model = HydrostaticFreeSurfaceModel(grid = ensemble_grid,\n                                                 tracers = tracers,\n                                                 buoyancy = BuoyancyTracer(),\n                                                 boundary_conditions = (; u=u_bcs, b=b_bcs),\n                                                 coriolis = coriolis_ensemble,\n                                                 closure = closure_ensemble)\n\n    ensemble_simulation = Simulation(ensemble_model; Δt=Δt, stop_time=first(observations).times[end])\n\n    return ensemble_simulation, closure\nend","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"The following illustrations uses a simple ensemble simulation with two ensemble members:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"ensemble_simulation, closure★ = build_ensemble_simulation(observations; Nensemble=3)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Free-parameters","page":"Intro to InverseProblem","title":"Free parameters","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"We construct some prior distributions for our free parameters. We found that it often helps to constrain the prior distributions so that neither very high nor very low values for diffusivities can be drawn out of the distribution.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"priors = (convective_κz = lognormal_with_mean_std(0.3, 0.05),\n          background_κz = lognormal_with_mean_std(2.5e-4, 0.25e-4))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"We also take the opportunity to collect a named tuple of the optimal parameters","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"θ★ = (convective_κz = closure★.convective_κz,\n      background_κz = closure★.background_κz)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Visualizing-the-priors","page":"Intro to InverseProblem","title":"Visualizing the priors","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"We visualize our prior distributions by plotting a huge number of samples:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"using OceanTurbulenceParameterEstimation.EnsembleKalmanInversions: convert_prior, inverse_parameter_transform\n\nNsamples = 50000000\n\nsamples(prior) = [inverse_parameter_transform(prior, θ) for θ in rand(convert_prior(prior), Nsamples)]\n\nconvective_κz_samples = samples(priors.convective_κz)\nbackground_κz_samples = samples(priors.background_κz)\n\nfig = Figure()\nax_top = Axis(fig[1, 1], xlabel = \"convective κᶻ [m² s⁻¹]\", ylabel = \"Density\")\ndensity!(ax_top, convective_κz_samples)\nxlims!(ax_top, 0, 10)\n\nax_bottom = Axis(fig[2, 1], xlabel = \"background κᶻ [m² s⁻¹]\", ylabel = \"Density\")\ndensity!(ax_bottom, background_κz_samples)\n\nsave(\"prior_visualization.svg\", fig)\nnothing # hide","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"(Image: )","category":"page"},{"location":"literated/intro_to_inverse_problems/#The-InverseProblem","page":"Intro to InverseProblem","title":"The InverseProblem","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"We can construct the inverse problem y = G(θ) + η. Here, y are the observations and G is the ensemble_model.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Using-InverseProblem-to-compute-forward_map","page":"Intro to InverseProblem","title":"Using InverseProblem to compute forward_map","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"As a sanity check we apply the forward_map on the calibration after we initialize all ensemble members with the true parameter values. We then confirm that the output of the forward_map matches the observations to machine precision.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"θ¹ = (convective_κz = 0.8 * θ★.convective_κz,\n      background_κz = 9.0 * θ★.background_κz)\n\nθ² = (convective_κz = 2.0 * θ★.convective_κz,\n      background_κz = 0.1 * θ★.background_κz)\n\nθ_ensemble = [θ★, θ¹, θ²]\n\nG = forward_map(calibration, θ_ensemble)\ny = observation_map(calibration)","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"The forward_map output G is a two-dimensional matrix whose first dimension is the size of the state space and whose second dimension is the ensemble_size. Here, we ensure that first ensemble member of the mapped output, which was run with the \"true\" parameters, is identical to the mapped observations:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"G[:, 1] ≈ y","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"Visualizing forward model output","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"Next we visualize the discrepency between solutions generated by true and non-optimal parameter sets θ¹ and θ². Time-series data from the ensemble run is collected by calibration.time_series_collector:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"time_series_collector = calibration.time_series_collector\ntimes = time_series_collector.times\n\n# Extract last save point and plot each solution component\nNt = length(times)\n\nb = time_series_collector.field_time_serieses.b[Nt]\nt = times[Nt]\nz = znodes(b)\n\n# The ensemble varies along the first, or `x`-dimension:\nb★ = interior(b)[1, 1, :]\nb¹ = interior(b)[2, 1, :]\nb² = interior(b)[3, 1, :]\n\nfig = Figure()\nax = Axis(fig[1, 1],\n          xlabel = \"Buoyancy [m s⁻²]\",\n          ylabel = \"Depth [m]\")\n\nb★_label = \"true b at t = \" * prettytime(t)\nb¹_label = \"b with $θ¹\"\nb²_label = \"b with $θ²\"\n\nlines!(ax, b★, z; label=b★_label, linewidth=2)\nlines!(ax, b¹, z; label=b¹_label, linewidth=2)\nlines!(ax, b², z; label=b²_label, linewidth=2)\n\naxislegend(ax, position=:lt)\n\nsave(\"ensemble_simulation_demonstration.svg\", fig); nothing # hide","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"(Image: )","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to InverseProblem","title":"Intro to InverseProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/internals/#Private-types-and-functions","page":"Private","title":"Private types and functions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Documentation for OceanTurbulenceParameterEstimation.jl's internal interface.","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation","page":"Private","title":"OceanTurbulenceParameterEstimation","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation]\nPublic = false\nPages   = [\"OceanTurbulenceParameterEstimation.jl\"]","category":"page"},{"location":"library/internals/#Observations","page":"Private","title":"Observations","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.Observations]\nPublic = false\nPages   = [\"Observations.jl\"]","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.FieldTimeSeriesCollector-Tuple{Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.FieldTimeSeriesCollector","text":"FieldTimeSeriesCollector(collected_fields, times; architecture=CPU())\n\nReturns a FieldTimeSeriesCollector for fields of simulation. fields is a NamedTuple of AbstractFields that are to be collected.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.SyntheticObservations","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.SyntheticObservations","text":"SyntheticObservations{F, G, T, P, M} <: AbstractObservation\n\nA time series of synthetic observations generated by Oceananigans.jl's simulations gridded as Oceananigans.jl fields.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.column_ensemble_interior-Tuple{Vector{var\"#s76\"} where var\"#s76\"<:SyntheticObservations, Any, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.column_ensemble_interior","text":"column_ensemble_interior(observations::Vector{<:SyntheticObservations}, field_name, time_indices::Vector, N_ens)\n\nReturns an Nensemble × Nbatch × Nz Array of (1, 1, Nz) field_name data, given Nbatch SyntheticObservations objects. The Nbatch × Nz data for field_name is copied Nensemble times to form a 3D Array.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.observation_names-Tuple{Vector{var\"#s31\"} where var\"#s31\"<:SyntheticObservations}","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.observation_names","text":"observation_names(obs::Vector{<:SyntheticObservations})\n\nReturn a Set representing the union of all names in obs.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#TurbulenceClosureParameters","page":"Private","title":"TurbulenceClosureParameters","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.TurbulenceClosureParameters]\nPublic = false\nPages   = [\"TurbulenceClosureParameters.jl\"]","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.FreeParameters-Tuple{Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.FreeParameters","text":"FreeParameters(priors; names = Symbol.(keys(priors)))\n\nReturn named FreeParameters with priors. Free parameter names are inferred from the keys of priors if not provided.\n\nExample\n\njulia> using Distributions, OceanTurbulenceParameterEstimation\n\njulia> priors = (ν = Normal(1e-4, 1e-5), κ = Normal(1e-3, 1e-5))\n(ν = Normal{Float64}(μ=0.0001, σ=1.0e-5), κ = Normal{Float64}(μ=0.001, σ=1.0e-5))\n\njulia> free_parameters = FreeParameters(priors)\nFreeParameters with 2 parameters\n├── names: (:ν, :κ)\n└── priors: Dict{Symbol, Any}\n    ├── ν => Normal{Float64}(μ=0.0001, σ=1.0e-5)\n    └── κ => Normal{Float64}(μ=0.001, σ=1.0e-5)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.closure_with_parameters-Tuple{Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.closure_with_parameters","text":"closure_with_parameters(closure, parameters)\n\nReturns a new object where for each (parameter_name, parameter_value) pair  in parameters, the value corresponding to the key in object that matches parameter_name is replaced with parameter_value.\n\nExample\n\njulia> using OceanTurbulenceParameterEstimation.TurbulenceClosureParameters: closure_with_parameters\n\njulia> struct ClosureSubModel; a; b end\n\njulia> struct Closure; test; c end\n\njulia> closure = Closure(ClosureSubModel(1, 2), 3)\nClosure(ClosureSubModel(1, 2), 3)\n\njulia> parameters = (a = 12, d = 7)\n(a = 12, d = 7)\n\njulia> closure_with_parameters(closure, parameters)\nClosure(ClosureSubModel(12, 2), 3)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.update_closure_ensemble_member!-Tuple{AbstractVector{T} where T, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.TurbulenceClosureParameters.update_closure_ensemble_member!","text":"update_closure_ensemble_member!(closures, p_ensemble, parameters)\n\nUse parameters to update closure from closures that corresponds to ensemble member p_ensemble.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#EnsembleKalmanInversions","page":"Private","title":"EnsembleKalmanInversions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.EnsembleKalmanInversions]\nPublic = false\nPages   = [\"EnsembleKalmanInversions.jl\"]","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.EnsembleKalmanInversion-Tuple{Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.EnsembleKalmanInversion","text":"EnsembleKalmanInversion(inverse_problem; noise_covariance=1e-2, resampler=NaNResampler())\n\nReturn an object that interfaces with EnsembleKalmanProcesses.jl and uses Ensemble Kalman Inversion to iteratively \"solve\" the inverse problem:\n\ny = G(θ) + η\n\nfor the parameters θ, where y is a \"normalized\" vector of observations, G(θ) is a forward map that predicts the observations, and η  N(0 Γ_y) is zero-mean random noise with covariance matrix Γ_y representing uncertainty in the observations.\n\nBy \"solve\", we mean that the iteration finds the parameter values θ that minimizes the distance between y and G(θ).\n\nThe \"forward map output\" G can have many interpretations. The specific statistics that G computes have to be selected for each use case to provide a concise summary of the complex model solution that contains the values that we would most like to match to the corresponding truth values y. For example, in the context of an ocean-surface boundary layer parametrization, this summary could be a vector of  concatenated u, v, b, e profiles at all or some time steps of the CATKE solution.\n\n(For more details on the Ensemble Kalman Inversion algorithm refer to the EnsembleKalmanProcesses.jl Documentation.)\n\nArguments\n\ninverse_problem :: InverseProblem: Represents an inverse problem representing the comparison between                                      synthetic observations generated by                                      Oceananigans.jl                                      and model predictions, also generated by Oceananigans.jl.\nnoise_covariance (AbstractMatrix or Number): normalized covariance representing observational                                                    uncertainty. If noise_covariance isa Number then                                                    it's converted to an identity matrix scaled by                                                    noise_covariance.\nresampler: controls resampling procedure when the forward map contains NaNs. See NaNResampler.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.IterationSummary","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.IterationSummary","text":"struct IterationSummary{P, M, C, V, E}\n\nContainer with information about each iteration of the Ensemble Kalman Process.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.IterationSummary-2","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.IterationSummary","text":"IterationSummary(eki, parameters, forward_map_output=nothing)\n\nReturn the summary for ensemble Kalman inversion eki with free parameters and forward_map_output.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.iterate!-Tuple{EnsembleKalmanInversion}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.iterate!","text":"iterate!(eki::EnsembleKalmanInversion; iterations=1)\n\nIterate the ensemble Kalman inversion problem eki forward by iterations.\n\nReturn\n\nbest_parameters: the ensemble mean of all parameter values after the last iteration.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.parameter_ensemble-Tuple{EnsembleKalmanInversion}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.parameter_ensemble","text":"parameter_ensemble(eki::EnsembleKalmanInversion)\n\nReturn a Vector of parameter sets (in physical / constrained space) for each ensemble member.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.resample!-Tuple{NaNResampler, Any, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.resample!","text":"resample!(resampler::NaNResampler, G, θ, eki)\n\nResamples the parameters θ of the eki process based on the number of NaN values inside the forward map output G.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.sample-NTuple{4, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.sample","text":"sample(eki, θ, G, n)\n\nGenerate n new particles sampled from a multivariate Normal distribution parameterized  by the ensemble mean and covariance computed based on the N_θ × N_ensemble ensemble  array θ, under the condition that all n particles lead to forward map outputs that are \"stable\" (don't include NaNs). G is the inverting forward map computed on ensemble θ.\n\nReturn an N_θ × n array of new particles, along with the inverting forward  map output corresponding to the new particles.\n\n\n\n\n\n","category":"method"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/perfect_baroclinic_adjustment_calibration.jl\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Perfect-baroclinic-adjustment-calibration-with-Ensemble-Kalman-Inversion","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"This example showcases a \"perfect model calibration\" of the two-dimensional baroclinic adjustement problem (depth-latitude) with eddies parametrized using Gent-McWilliams–Redi isoneutral diffusion closure. We use output for buoyancy (b) and a passive-tracer concentration (c) to calibrate the parametrization.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Install-dependencies","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using Pkg\npkg\"add Oceananigans, Distributions, CairoMakie, OceanTurbulenceParameterEstimation\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First we load few things","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using OceanTurbulenceParameterEstimation\nusing Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.TurbulenceClosures: FluxTapering\nusing Oceananigans.Models.HydrostaticFreeSurfaceModels: SliceEnsembleSize\nusing Distributions\nusing Printf\nusing LinearAlgebra: norm","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Set-up-the-problem-and-generate-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Set up the problem and generate observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Define the  \"true\" skew and symmetric diffusivity coefficients. These are the parameter values that we use to generate the data. Then, we'll see if the EKI calibration can recover these values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"κ_skew = 1000.0       # [m² s⁻¹] skew diffusivity\nκ_symmetric = 900.0   # [m² s⁻¹] symmetric diffusivity\nnothing # hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We gather the \"true\" parameters in a named tuple θ_*:","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"θ★ = (κ_skew = κ_skew, κ_symmetric = κ_symmetric)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The experiment name and where the synthetic observations will be saved.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"experiment_name = \"baroclinic_adjustment\"\ndata_path = experiment_name * \".jld2\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The domain, number of grid points, and other parameters.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"architecture = CPU()      # CPU or GPU?\nLy = 1000kilometers       # north-south extent [m]\nLz = 1kilometers          # depth [m]\nNy = 64                   # grid points in north-south direction\nNz = 16                   # grid points in the vertical\nΔt = 10minute             # time-step\nstop_time = 1days         # length of run\nsave_interval = 0.25days  # save observation every so often\n\ngenerate_observations = true\nnothing # hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The isopycnal skew-symmetric diffusivity closure.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"gerdes_koberle_willebrand_tapering = FluxTapering(1e-2)\ngent_mcwilliams_diffusivity = IsopycnalSkewSymmetricDiffusivity(κ_skew = κ_skew,\n                                                                κ_symmetric = κ_symmetric,\n                                                                slope_limiter = gerdes_koberle_willebrand_tapering)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Generate-synthetic-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Generate synthetic observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"if generate_observations || !(isfile(data_path))\n    grid = RectilinearGrid(architecture,\n                           topology = (Flat, Bounded, Bounded),\n                           size = (Ny, Nz),\n                           y = (-Ly/2, Ly/2),\n                           z = (-Lz, 0),\n                           halo = (3, 3))\n\n    model = HydrostaticFreeSurfaceModel(grid = grid,\n                                        tracers = (:b, :c),\n                                        buoyancy = BuoyancyTracer(),\n                                        coriolis = BetaPlane(latitude=-45),\n                                        closure = gent_mcwilliams_diffusivity,\n                                        free_surface = ImplicitFreeSurface())\n\n    @info \"Built $model.\"\n\n    ##### Initial conditions of an unstable buoyancy front\n\n    \"\"\"\n    Linear ramp from 0 to 1 between -Δy/2 and +Δy/2.\n\n    For example:\n\n    y < y₀           => ramp = 0\n    y₀ < y < y₀ + Δy => ramp = y / Δy\n    y > y₀ + Δy      => ramp = 1\n    \"\"\"\n    ramp(y, Δy) = min(max(0, y/Δy + 1/2), 1)\n\n    N² = 4e-6             # [s⁻²] buoyancy frequency / stratification\n    M² = 8e-8             # [s⁻²] horizontal buoyancy gradient\n\n    Δy = 50kilometers     # horizontal extent of the font\n\n    Δc_y = 2Δy            # horizontal extent of initial tracer concentration\n    Δc_z = 50             # [m] vertical extent of initial tracer concentration\n\n    Δb = Δy * M²          # inital buoyancy jump\n\n    bᵢ(x, y, z) = N² * z + Δb * ramp(y, Δy)\n    cᵢ(x, y, z) = exp(-y^2 / 2Δc_y^2) * exp(-(z + Lz/2)^2 / (2Δc_z^2))\n\n    set!(model, b=bᵢ, c=cᵢ)\n\n    simulation = Simulation(model, Δt=Δt, stop_time=stop_time)\n\n    simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),\n                                                          schedule = TimeInterval(save_interval),\n                                                          prefix = experiment_name,\n                                                          array_type = Array{Float64},\n                                                          field_slicer = nothing,\n                                                          force = true)\n\n    run!(simulation)\nend","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Load-truth-data-as-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Load truth data as observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"observations = SyntheticObservations(data_path, field_names=(:b, :c), normalization=ZScore())","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Calibration-with-Ensemble-Kalman-Inversion","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Ensemble-model","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Ensemble model","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First we set up an ensemble model,","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_size = 20\n\nslice_ensemble_size = SliceEnsembleSize(size=(Ny, Nz), ensemble=ensemble_size)\n@show ensemble_grid = RectilinearGrid(architecture,\n                                      size=slice_ensemble_size,\n                                      topology = (Flat, Bounded, Bounded),\n                                      y = (-Ly/2, Ly/2),\n                                      z = (-Lz, 0),\n                                      halo=(3, 3))\n\nclosure_ensemble = [deepcopy(gent_mcwilliams_diffusivity) for i = 1:ensemble_size]\n\n@show ensemble_model = HydrostaticFreeSurfaceModel(grid = ensemble_grid,\n                                                   tracers = (:b, :c),\n                                                   buoyancy = BuoyancyTracer(),\n                                                   coriolis = BetaPlane(latitude=-45),\n                                                   closure = closure_ensemble,\n                                                   free_surface = ImplicitFreeSurface())","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"and then we create an ensemble simulation:","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_simulation = Simulation(ensemble_model; Δt, stop_time)\n\nensemble_simulation","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Free-parameters","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Free parameters","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We construct some prior distributions for our free parameters. We found that it often helps to constrain the prior distributions so that neither very high nor very low values for diffusivities can be drawn out of the distribution.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"priors = (\n    κ_skew = ConstrainedNormal(0.0, 1.0, 400.0, 1300.0),\n    κ_symmetric = ConstrainedNormal(0.0, 1.0, 700.0, 1700.0)\n)\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"To visualize the prior distributions we randomly sample out values from then and plot the p.d.f.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using CairoMakie\nusing OceanTurbulenceParameterEstimation.EnsembleKalmanInversions: convert_prior, inverse_parameter_transform\n\nsamples(prior) = [inverse_parameter_transform(prior, x) for x in rand(convert_prior(prior), 10000000)]\n\nsamples_κ_skew = samples(priors.κ_skew)\nsamples_κ_symmetric = samples(priors.κ_symmetric)\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"Diffusivities [m² s⁻¹]\", ylabel = \"PDF\")\ndensities = []\npush!(densities, density!(ax, samples_κ_skew))\npush!(densities, density!(ax, samples_κ_symmetric))\nLegend(fig[1, 2], densities, [\"κ_skew\", \"κ_symmetric\"], position = :lb)\n\nsave(\"visualize_prior_diffusivities_baroclinic_adjustment.svg\", fig); nothing # hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#The-inverse-problem","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"The inverse problem","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We can construct the inverse problem y = G(θ) + η. Here, y are the observations and G is the ensemble_model.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Assert-that-G(θ_*)-y","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Assert that G(θ_*)  y","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"As a sanity check we apply the forward_map on the calibration after we initialize all ensemble members with the true parameter values. We then confirm that the output of the forward_map matches the observations to machine precision.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"G = forward_map(calibration, [θ★])\ny = observation_map(calibration)\nnothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The forward_map output x is a two-dimensional matrix whose first dimension is the size of the state space (here, 2 N_y N_z; the 2 comes from the two tracers we used as observations) and whose second dimension is the ensemble_size. In the case above, all columns of x are identical.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"mean(G, dims=2) ≈ y","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Next, we construct an EnsembleKalmanInversion (EKI) object,","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"eki = EnsembleKalmanInversion(calibration; noise_covariance = 1e-2)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"params = iterate!(eki; iterations = 5)\n\n@show params","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Last, we visualize few metrics regarding how the EKI calibration went about.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"θ̅(iteration) = [eki.iteration_summaries[iteration].ensemble_mean...]\nvarθ(iteration) = eki.iteration_summaries[iteration].ensemble_var\n\nweight_distances = [norm(θ̅(iter) - [θ★[1], θ★[2]]) for iter in 1:eki.iteration]\noutput_distances = [norm(forward_map(calibration, θ̅(iter))[:, 1] - y) for iter in 1:eki.iteration]\nensemble_variances = [varθ(iter) for iter in 1:eki.iteration]\n\nf = Figure()\nlines(f[1, 1], 1:eki.iteration, weight_distances, color = :red, linewidth = 2,\n      axis = (title = \"Parameter distance\",\n              xlabel = \"Iteration\",\n              ylabel=\"|θ̅ₙ - θ⋆|\",\n              yscale = log10))\nlines(f[1, 2], 1:eki.iteration, output_distances, color = :blue, linewidth = 2,\n      axis = (title = \"Output distance\",\n              xlabel = \"Iteration\",\n              ylabel=\"|G(θ̅ₙ) - y|\",\n              yscale = log10))\nax3 = Axis(f[2, 1:2], title = \"Parameter convergence\",\n           xlabel = \"Iteration\",\n           ylabel = \"Ensemble variance\",\n           yscale = log10)\n\nfor (i, pname) in enumerate(free_parameters.names)\n    ev = getindex.(ensemble_variances, i)\n    lines!(ax3, 1:eki.iteration, ev / ev[1], label = String(pname), linewidth = 2)\nend\n\naxislegend(ax3, position = :rt)\nsave(\"summary_baroclinic_adjustment.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"f = Figure()\n\naxtop = Axis(f[1, 1])\n\naxmain = Axis(f[2, 1],\n              xlabel = \"κ_skew [m² s⁻¹]\",\n              ylabel = \"κ_symmetric [m² s⁻¹]\")\n\naxright = Axis(f[2, 2])\nscatters = []\nlabels = String[]\n\nfor iteration in [0, 1, 2, 5]\n    # Make parameter matrix\n    parameters = eki.iteration_summaries[iteration].parameters\n    Nensemble = length(parameters)\n    Nparameters = length(first(parameters))\n    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:Nparameters]\n\n    label = iteration == 0 ? \"Initial ensemble\" : \"Iteration $iteration\"\n    push!(labels, label)\n    push!(scatters, scatter!(axmain, parameter_ensemble_matrix))\n    density!(axtop, parameter_ensemble_matrix[:, 1])\n    density!(axright, parameter_ensemble_matrix[:, 2], direction = :y)\nend\n\nvlines!(axmain, [κ_skew], color = :red)\nvlines!(axtop, [κ_skew], color = :red)\n\nhlines!(axmain, [κ_symmetric], color = :red)\nhlines!(axright, [κ_symmetric], color = :red)\n\ncolsize!(f.layout, 1, Fixed(300))\ncolsize!(f.layout, 2, Fixed(200))\n\nrowsize!(f.layout, 1, Fixed(200))\nrowsize!(f.layout, 2, Fixed(300))\n\nLegend(f[1, 2], scatters, labels, position = :lb)\n\nhidedecorations!(axtop, grid = false)\nhidedecorations!(axright, grid = false)\n\nxlims!(axmain, 350, 1350)\nxlims!(axtop, 350, 1350)\nylims!(axmain, 650, 1750)\nylims!(axright, 650, 1750)\nxlims!(axright, 0, 0.025)\nylims!(axtop, 0, 0.025)\n\nsave(\"distributions_baroclinic_adjustment.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/intro_to_observations.jl\"","category":"page"},{"location":"literated/intro_to_observations/#Intro-to-observations","page":"Intro to observations","title":"Intro to observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"This example demonstrates the features of SyntheticObservations when constructed from  \"synthetic observations\" generated by an Oceananigans Simulation.","category":"page"},{"location":"literated/intro_to_observations/#Install-dependencies","page":"Intro to observations","title":"Install dependencies","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"First we load few things","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"using OceanTurbulenceParameterEstimation\nusing Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.TurbulenceClosures: ConvectiveAdjustmentVerticalDiffusivity\nusing CairoMakie","category":"page"},{"location":"literated/intro_to_observations/#Generating-synthetic-observations","page":"Intro to observations","title":"Generating synthetic observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"We define a utility function for constructing synthetic observations,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"default_closure = ConvectiveAdjustmentVerticalDiffusivity(; convective_κz = 1.0,\n                                                            convective_νz = 0.9,\n                                                            background_κz = 1e-4,\n                                                            background_νz = 1e-5)\n\nfunction generate_synthetic_observations(name = \"convective_adjustment\"; Nz = 32, Lz = 64,\n                                         Qᵇ = +1e-8, Qᵘ = -1e-5, f₀ = 1e-4, N² = 1e-6,\n                                         Δt = 10.0, stop_time = 12hours, overwrite=false,\n                                         tracers = :b, closure = default_closure)\n\n    data_path = name * \".jld2\"\n\n    if isfile(data_path)\n        @warn(\"Using existing data at $data_path. \" *\n              \"Please delete this file if you wish to generate new data.\")\n\n        return data_path\n    end\n\n    grid = RectilinearGrid(size=Nz, z=(-Lz, 0), topology=(Flat, Flat, Bounded))\n    u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ))\n    b_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵇ), bottom = GradientBoundaryCondition(N²))\n\n    model = HydrostaticFreeSurfaceModel(; grid, tracers, closure,\n                                          buoyancy = BuoyancyTracer(),\n                                          boundary_conditions = (u=u_bcs, b=b_bcs),\n                                          coriolis = FPlane(f=f₀))\n\n    set!(model, b = (x, y, z) -> N² * z)\n    simulation = Simulation(model; Δt, stop_time)\n    init_with_parameters(file, model) = file[\"parameters\"] = (; Qᵇ, Qᵘ, Δt, N², tracers=keys(model.tracers))\n\n    simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),\n                                                          schedule = TimeInterval(stop_time/3),\n                                                          prefix = name,\n                                                          array_type = Array{Float64},\n                                                          field_slicer = nothing,\n                                                          init = init_with_parameters,\n                                                          force = true)\n\n    run!(simulation)\n\n    return data_path\nend","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"and invoke it:","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"data_path = generate_synthetic_observations()","category":"page"},{"location":"literated/intro_to_observations/#Specifying-observations","page":"Intro to observations","title":"Specifying observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"When synthetic observations are constructed from simulation data, we can select","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"The fields to include via field_names\nWhich data in the time-series to include via the times keyword. This can be used to change the initial condition for a calibration run.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"For example, to build observations with a single field we write,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"single_field_observations = SyntheticObservations(data_path, field_names=:b, normalization=ZScore())","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"To build observations with two fields we write","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"two_field_observations = SyntheticObservations(data_path, field_names=(:u, :b), normalization=ZScore())","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"And to build observations with specified times we write","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"times = single_field_observations.times[2:end]\nspecified_times_observations = SyntheticObservations(data_path, field_names=(:u, :b), normalization=ZScore(), times=times)","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"Notice that in the last case, specified_times_observations.times is missing 0.0.","category":"page"},{"location":"literated/intro_to_observations/#Visualizing-observations","page":"Intro to observations","title":"Visualizing observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"For this we include the initial condition and v velocity component,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"observations = SyntheticObservations(data_path, field_names=(:u, :v, :b), normalization=ZScore())\n\nfig = Figure()\n\nax_b = Axis(fig[1, 1], xlabel = \"Buoyancy [m s⁻²]\", ylabel = \"z [m]\")\nax_u = Axis(fig[1, 2], xlabel = \"Velocities [m s⁻¹]\", ylabel = \"z [m]\")\n\nz = znodes(Center, observations.grid)\n\ncolorcycle = [:black, :red, :blue, :orange, :pink]\n\nfor i = 1:length(observations.times)\n    b_ = observations.field_time_serieses.b[i]\n    u_ = observations.field_time_serieses.u[i]\n    v_ = observations.field_time_serieses.v[i]\n    t_ = observations.times[i]\n\n    label = \"t = \" * prettytime(t_)\n    u_label = i == 1 ? \"u, \" * label : label\n    v_label = i == 1 ? \"v, \" * label : label\n\n    lines!(ax_b, 1e4 * interior(b_)[1, 1, :], z; label, color=colorcycle[i]) # convert units from m s⁻² to 10⁻⁴ m s⁻²\n    lines!(ax_u, interior(u_)[1, 1, :], z; linestyle=:solid, color=colorcycle[i], label=u_label)\n    lines!(ax_u, interior(v_)[1, 1, :], z; linestyle=:dash, color=colorcycle[i], label=v_label)\nend\n\naxislegend(ax_b, position=:rb)\naxislegend(ax_u, position=:lb, merge=true)\n\nsave(\"intro_to_observations.svg\", fig)","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"(Image: )","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"Hint: if using a REPL or notebook, try using Pkg; Pkg.add(\"ElectronDisplay\"); using ElectronDisplay; display(fig) To see the figure in a window.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/lesbrary_catke_calibration.jl\"","category":"page"},{"location":"literated/lesbrary_catke_calibration/#CAKTE-calibration-with-Ensemble-Kalman-Inversion-using-LESbrary-data","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/#Install-dependencies","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"Install dependencies","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"using Oceananigans\nusing Oceananigans.Units\nusing OceanTurbulenceParameterEstimation\nusing LinearAlgebra, CairoMakie, DataDeps\n\nusing Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities:\n    CATKEVerticalDiffusivity, MixingLength","category":"page"},{"location":"literated/lesbrary_catke_calibration/#Using-LESbrary-data","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"Using LESbrary data","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"OceanTurbulenceParameterEstimation.jl provides paths to synthetic observations derived from high-fidelity large eddy simulations. In this example, we illustrate calibration of a turbulence parameterization to one of these simulations:","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"data_path = datadep\"two_day_suite_4m/strong_wind_instantaneous_statistics.jld2\"\ntimes = [2hours, 6hours, 12hours]\nfield_names = (:b, :u, :v, :e)\n\n# Use a special normalization that emphasizes buoyancy and de-emphasizes TKE\nnormalization = (b = ZScore(),\n                 u = ZScore(),\n                 v = ZScore(),\n                 e = RescaledZScore(0.1))\n\nobservations = SyntheticObservations(data_path; field_names, times, normalization)","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Let's take a look at the observations. We define a few plotting utilities along the way to use later in the example:","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"colorcycle = [:black, :red, :darkblue, :orange, :pink1, :seagreen, :magenta2]\nmarkercycle = [:rect, :utriangle, :star5, :circle, :cross, :+, :pentagon]\n\nfunction make_figure_axes()\n    fig = Figure(resolution=(1200, 400))\n    ax_b = Axis(fig[1, 1], xlabel = \"Buoyancy \\n[cm s⁻²]\", ylabel = \"z [m]\")\n    ax_u = Axis(fig[1, 2], xlabel = \"x-velocity, u \\n[cm s⁻¹]\")\n    ax_v = Axis(fig[1, 3], xlabel = \"y-velocity, v \\n[cm s⁻¹]\")\n    ax_e = Axis(fig[1, 4], xlabel = \"Turbulent kinetic energy \\n[cm² s⁻²]\")\n    return fig, (ax_b, ax_u, ax_v, ax_e)\nend\n\nfunction plot_fields!(axs, b, u, v, e, label, color)\n    z = znodes(Center, b.grid)\n    # Note unit conversions below, eg m s⁻² -> cm s⁻²:\n    lines!(axs[1], 1e2 * interior(b)[1, 1, :], z; color, label)\n    lines!(axs[2], 1e2 * interior(u)[1, 1, :], z; color, label)\n    lines!(axs[3], 1e2 * interior(v)[1, 1, :], z; color, label)\n    lines!(axs[4], 1e4 * interior(e)[1, 1, :], z; color, label)\n    return nothing\nend","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"And then plot the evolution of the observed fields,","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"fig, axs = make_figure_axes()\n\nfor (i, t) in enumerate(times)\n    fields = map(name -> observations.field_time_serieses[name][i], field_names)\n    plot_fields!(axs, fields..., \"t = \" * prettytime(t), colorcycle[i])\nend\n\n[axislegend(ax, position=:rb, merge=true, fontsize=10) for ax in axs]\n\nsave(\"lesbrary_synthetic_observations.svg\", fig); nothing # hide","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"(Image: )","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Behold, boundary layer turbulence!","category":"page"},{"location":"literated/lesbrary_catke_calibration/#Calibration","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"Calibration","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Next, we build a simulation of an ensemble of column models to calibrate CATKE using Ensemble Kalman Inversion. We configure CATKE without convective adjustment and with constant (rather than Richardson-number-dependent) diffusivity parameters.","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"catke_mixing_length = MixingLength(Cᴷcʳ=0.0, Cᴷuʳ=0.0, Cᴷeʳ=0.0)\ncatke = CATKEVerticalDiffusivity(mixing_length=catke_mixing_length)\n\nsimulation = ensemble_column_model_simulation(observations;\n                                              Nensemble = 40,\n                                              architecture = CPU(),\n                                              tracers = (:b, :e),\n                                              closure = catke)","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"The simulation is initialized with neutral boundary conditions and a default time-step, which we modify for our particular problem:","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Qᵘ = simulation.model.velocities.u.boundary_conditions.top.condition\nQᵇ = simulation.model.tracers.b.boundary_conditions.top.condition\nN² = simulation.model.tracers.b.boundary_conditions.bottom.condition\n\nsimulation.Δt = 10.0\n\nQᵘ .= observations.metadata.parameters.momentum_flux\nQᵇ .= observations.metadata.parameters.buoyancy_flux\nN² .= observations.metadata.parameters.N²_deep","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"We identify a subset of the CATKE parameters to calibrate by specifying parameter names and prior distributions:","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"priors = (Cᴰ   = lognormal_with_mean_std(0.02, 0.005),\n          Cᵂu★ = lognormal_with_mean_std(1.5, 0.25),\n          Cᴸᵇ  = lognormal_with_mean_std(0.01, 0.005),\n          Cᴷu⁻ = ConstrainedNormal(1.5, 0.1, 0.0, 4.0),\n          Cᴷc⁻ = ConstrainedNormal(1e-3, 1e-4, 0.0, 1.0),\n          Cᴷe⁻ = ConstrainedNormal(1.2, 0.25, 0.0, 3.0))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"TODO: explain the meaning of each parameter The prior information comes from experience, prior calibration runs, and educated guesses.","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"calibration = InverseProblem(observations, simulation, free_parameters)","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Next, we calibrate, using a relatively large noise to reflect our uncertainty about how close the observations and model can really get,","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"eki = EnsembleKalmanInversion(calibration;\n                              noise_covariance = 1e-2,\n                              resampler = NaNResampler(abort_fraction=0.5))\n\niterate!(eki; iterations = 5)","category":"page"},{"location":"literated/lesbrary_catke_calibration/#Results","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"Results","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"To analyze the reuslts, we build a new simulation with just one ensemble member to evaluate pasome utilities for analyzing the results:","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Nt = length(observations.times)\nNiter = length(eki.iteration_summaries) - 1\nmodeled_time_serieses = calibration.time_series_collector.field_time_serieses\nobserved = map(name -> observations.field_time_serieses[name][Nt], field_names)\nmodeled = map(name -> modeled_time_serieses[name][Nt], field_names)\n\nfunction compare_model_observations(model_label=\"modeled\")\n    fig, axs = make_figure_axes()\n    plot_fields!(axs, observed..., \"observed at t = \" * prettytime(times[end]), :black)\n    plot_fields!(axs, modeled..., model_label, :blue)\n    [axislegend(ax, position=:rb, merge=true, fontsize=10) for ax in axs]\n    return fig\nend","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Now we execute forward runs for the initial ensemble mean,","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"initial_parameters = eki.iteration_summaries[0].ensemble_mean\nforward_run!(calibration, initial_parameters)\nfig = compare_model_observations(\"modeled after 0 iterations\")\n\nsave(\"model_observation_comparison_iteration_0.svg\", fig); nothing # hide","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"(Image: )","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"and the final ensemble mean, representing our \"best\" parameter set,","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"best_parameters = eki.iteration_summaries[end].ensemble_mean\nforward_run!(calibration, best_parameters)\nfig = compare_model_observations(\"modeled after $Niter iterations\")\n\nsave(\"model_observation_comparison_final_iteration.svg\", fig); nothing # hide","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"(Image: )","category":"page"},{"location":"literated/lesbrary_catke_calibration/#Parameter-evolution","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"Parameter evolution","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"To understand how results changed over the EKI iterations, we look at the evoluation of the ensemble means,","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"ensemble_means = NamedTuple(n => map(summary -> summary.ensemble_mean[n], eki.iteration_summaries)\n                            for n in calibration.free_parameters.names)\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"Ensemble Kalman iteration\", ylabel = \"Parameter value\")\n\nfor (i, name) in enumerate(calibration.free_parameters.names)\n    label = string(name)\n    marker = markercycle[i]\n    color = colorcycle[i]\n    scatterlines!(ax, 0:Niter, parent(ensemble_means[name]); marker, color, label)\nend\n\naxislegend(ax, position=:rb)\n\nsave(\"lesbrary_catke_parameter_evolution.svg\", fig); nothing # hide","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"(Image: )","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#OceanTurbulenceParameterEstimation.jl-Documentation","page":"Home","title":"OceanTurbulenceParameterEstimation.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OceanTurbulenceParameterEstimation provides a framework to calibrate turbulence closure parametrizations for ocean models.","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for OceanTurbulenceParameterEstimation.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"library/public/#OceanTurbulenceParameterEstimation","page":"Public","title":"OceanTurbulenceParameterEstimation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation]\nPrivate = false\nPages   = [\"OceanTurbulenceParameterEstimation.jl\"]","category":"page"},{"location":"library/public/#Observations","page":"Public","title":"Observations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.Observations]\nPrivate = false\nPages   = [\"Observations.jl\"]","category":"page"},{"location":"library/public/#TurbulenceClosureParameters","page":"Public","title":"TurbulenceClosureParameters","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.TurbulenceClosureParameters]\nPrivate = false\nPages   = [\"TurbulenceClosureParameters.jl\"]","category":"page"},{"location":"library/public/#EnsembleKalmanInversions","page":"Public","title":"EnsembleKalmanInversions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.EnsembleKalmanInversions]\nPrivate = false\nPages   = [\"EnsembleKalmanInversions.jl\"]","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/perfect_convective_adjustment_calibration.jl\"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Perfect-convective-adjustment-calibration-with-Ensemble-Kalman-Inversion","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"This example calibrates a convective adjustment model in the \"perfect model context\". In this context, synthetic observations are generated by a convective adjustment model with \"true\" parameters. The true parameters are then \"rediscovered\" by calibrating the model to match the synthetic observations.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"We use the discrepency between observed and modeled buoyancy b to calibrate the convective adjustment model. The calibration problem is solved by Ensemble Kalman Inversion. For more information about Ensemble Kalman Inversion, see the EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Install-dependencies","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"using OceanTurbulenceParameterEstimation, LinearAlgebra, CairoMakie","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"We reuse some some code from a previous example to generate observations,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"examples_path = joinpath(pathof(OceanTurbulenceParameterEstimation), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_inverse_problems.jl\"))\n\ndata_path = generate_synthetic_observations()\nobservations = SyntheticObservations(data_path, field_names=:b, normalization=ZScore())","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"and an ensemble_simulation,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_simulation, closure★ = build_ensemble_simulation(observations; Nensemble=50)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The handy utility function build_ensemble_simulation also tells us the optimal parameters that were used when generating the synthetic observations:","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"@show θ★ = (convective_κz = closure★.convective_κz, background_κz = closure★.background_κz)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#The-InverseProblem","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"The InverseProblem","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"To build an inverse problem we first define free parameters. Here we calibrate convective_κz and background_κz, using log-normal priors to prevent the parameters from becoming negative:","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"priors = (convective_κz = lognormal_with_mean_std(0.3, 0.5),\n          background_κz = lognormal_with_mean_std(2.5e-4, 2.5e-5))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The InverseProblem is then constructed from observations, ensemble_simulation, and free_parameters,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"For more information about the above steps, see Intro to observations and Intro to InverseProblem.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Ensemble-Kalman-Inversion","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"Next, we construct an EnsembleKalmanInversion (EKI) object,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The calibration is done here using Ensemble Kalman Inversion. For more information about the algorithm refer to EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"noise_variance = observation_map_variance_across_time(calibration)[1, :, 1] .+ 1e-5\n\neki = EnsembleKalmanInversion(calibration; noise_covariance = Matrix(Diagonal(noise_variance)))","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"iterate!(eki; iterations = 10)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"Last, we visualize the outputs of EKI calibration.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"θ̅(iteration) = [eki.iteration_summaries[iteration].ensemble_mean...]\nvarθ(iteration) = eki.iteration_summaries[iteration].ensemble_var\n\nweight_distances = [norm(θ̅(iter) - [θ★[1], θ★[2]]) for iter in 0:eki.iteration]\noutput_distances = [norm(forward_map(calibration, θ̅(iter))[:, 1] - y) for iter in 0:eki.iteration]\nensemble_variances = [varθ(iter) for iter in 0:eki.iteration]\n\nf = Figure()\n\nlines(f[1, 1], 0:eki.iteration, weight_distances, color = :red, linewidth = 2,\n      axis = (title = \"Parameter distance\",\n              xlabel = \"Iteration\",\n              ylabel = \"|θ̅ₙ - θ★|\"))\n\nlines(f[1, 2], 0:eki.iteration, output_distances, color = :blue, linewidth = 2,\n      axis = (title = \"Output distance\",\n              xlabel = \"Iteration\",\n              ylabel = \"|G(θ̅ₙ) - y|\"))\n\nax3 = Axis(f[2, 1:2],\n           title = \"Parameter convergence\",\n           xlabel = \"Iteration\",\n           ylabel = \"Ensemble variance\",\n           yscale = log10)\n\nfor (i, pname) in enumerate(free_parameters.names)\n    ev = getindex.(ensemble_variances, i)\n    lines!(ax3, 0:eki.iteration, ev / ev[1], label = String(pname), linewidth = 2)\nend\n\naxislegend(ax3, position = :rt)\n\nsave(\"summary_convective_adjustment_eki.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"f = Figure()\n\naxtop = Axis(f[1, 1])\n\naxmain = Axis(f[2, 1],\n              xlabel = \"convective_κz [m² s⁻¹]\",\n              ylabel = \"background_κz [m² s⁻¹]\")\n\naxright = Axis(f[2, 2])\nscatters = []\nlabels = String[]\n\nfor iteration in [0, 1, 2, 10]\n    # Make parameter matrix\n    parameters = eki.iteration_summaries[iteration].parameters\n    Nensemble = length(parameters)\n    Nparameters = length(first(parameters))\n    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:Nparameters]\n\n    label = iteration == 0 ? \"Initial ensemble\" : \"Iteration $iteration\"\n    push!(labels, label)\n    push!(scatters, scatter!(axmain, parameter_ensemble_matrix))\n    density!(axtop, parameter_ensemble_matrix[:, 1])\n    density!(axright, parameter_ensemble_matrix[:, 2], direction = :y)\nend\n\nvlines!(axmain, [θ★.convective_κz], color = :red)\nvlines!(axtop, [θ★.convective_κz], color = :red)\n\nhlines!(axmain, [θ★.background_κz], color = :red)\nhlines!(axright, [θ★.background_κz], color = :red)\n\ncolsize!(f.layout, 1, Fixed(300))\ncolsize!(f.layout, 2, Fixed(200))\nrowsize!(f.layout, 1, Fixed(200))\nrowsize!(f.layout, 2, Fixed(300))\n\nLegend(f[1, 2], scatters, labels, position = :lb)\n\nhidedecorations!(axtop, grid = false)\nhidedecorations!(axright, grid = false)\n\nxlims!(axmain, -0.25, 3.2)\nxlims!(axtop, -0.25, 3.2)\nylims!(axmain, 5e-5, 35e-5)\nylims!(axright, 5e-5, 35e-5)\n\nsave(\"distributions_convective_adjustment_eki.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"}]
}
