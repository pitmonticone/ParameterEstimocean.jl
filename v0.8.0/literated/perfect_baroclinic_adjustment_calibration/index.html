<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion · OceanTurbulenceParameterEstimation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://clima.github.io/OceanTurbulenceParameterEstimation/dev/literated/perfect_baroclinic_adjustment_calibration/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OceanTurbulenceParameterEstimation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation_instructions/">Installation Instructions</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../intro_to_observations/">Intro to observations</a></li><li><a class="tocitem" href="../intro_to_inverse_problems/">Intro to <code>InverseProblem</code></a></li><li><a class="tocitem" href="../exploring_priors/">Specifying and fine-tuning prior distributions</a></li><li><a class="tocitem" href="../perfect_convective_adjustment_calibration/">Perfect convective adjustment calibration with Ensemble Kalman Inversion</a></li><li><a class="tocitem" href="../perfect_catke_calibration/">Perfect CAKTE calibration with Ensemble Kalman Inversion</a></li><li><a class="tocitem" href="../lesbrary_catke_calibration/">CAKTE calibration with Ensemble Kalman Inversion using LESbrary data</a></li><li class="is-active"><a class="tocitem" href>Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion</a><ul class="internal"><li><a class="tocitem" href="#Install-dependencies"><span>Install dependencies</span></a></li><li><a class="tocitem" href="#Set-up-the-problem-and-generate-observations"><span>Set up the problem and generate observations</span></a></li><li><a class="tocitem" href="#Generate-synthetic-observations"><span>Generate synthetic observations</span></a></li><li><a class="tocitem" href="#Load-truth-data-as-observations"><span>Load truth data as observations</span></a></li><li><a class="tocitem" href="#Calibration-with-Ensemble-Kalman-Inversion"><span>Calibration with Ensemble Kalman Inversion</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/outline/">Contents</a></li><li><a class="tocitem" href="../../library/public/">Public</a></li><li><a class="tocitem" href="../../library/internals/">Private</a></li><li><a class="tocitem" href="../../library/function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/perfect_baroclinic_adjustment_calibration.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Perfect-baroclinic-adjustment-calibration-with-Ensemble-Kalman-Inversion"><a class="docs-heading-anchor" href="#Perfect-baroclinic-adjustment-calibration-with-Ensemble-Kalman-Inversion">Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion</a><a id="Perfect-baroclinic-adjustment-calibration-with-Ensemble-Kalman-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Perfect-baroclinic-adjustment-calibration-with-Ensemble-Kalman-Inversion" title="Permalink"></a></h1><p>This example showcases a &quot;perfect model calibration&quot; of the two-dimensional baroclinic adjustement problem (depth-latitude) with eddies parametrized using Gent-McWilliams–Redi isoneutral diffusion closure. We use output for buoyancy (<span>$b$</span>) and a passive-tracer concentration (<span>$c$</span>) to calibrate the parametrization.</p><h2 id="Install-dependencies"><a class="docs-heading-anchor" href="#Install-dependencies">Install dependencies</a><a id="Install-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Install-dependencies" title="Permalink"></a></h2><p>First let&#39;s make sure we have all required packages installed.</p><pre><code class="language-julia hljs">using Pkg
pkg&quot;add Oceananigans, Distributions, CairoMakie, OceanTurbulenceParameterEstimation&quot;</code></pre><p>First we load few things</p><pre><code class="language-julia hljs">using OceanTurbulenceParameterEstimation

using Oceananigans
using Oceananigans.Units
using Oceananigans.TurbulenceClosures: FluxTapering
using Oceananigans.Models.HydrostaticFreeSurfaceModels: SliceEnsembleSize
using Distributions
using Printf
using LinearAlgebra: norm</code></pre><h2 id="Set-up-the-problem-and-generate-observations"><a class="docs-heading-anchor" href="#Set-up-the-problem-and-generate-observations">Set up the problem and generate observations</a><a id="Set-up-the-problem-and-generate-observations-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-problem-and-generate-observations" title="Permalink"></a></h2><p>Define the  &quot;true&quot; skew and symmetric diffusivity coefficients. These are the parameter values that we use to generate the data. Then, we&#39;ll see if the EKI calibration can recover these values.</p><pre><code class="language-julia hljs">κ_skew = 1000.0       # [m² s⁻¹] skew diffusivity
κ_symmetric = 900.0   # [m² s⁻¹] symmetric diffusivity</code></pre><p>We gather the &quot;true&quot; parameters in a named tuple <span>$θ_*$</span>:</p><pre><code class="language-julia hljs">θ★ = (κ_skew = κ_skew, κ_symmetric = κ_symmetric)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(κ_skew = 1000.0, κ_symmetric = 900.0)</code></pre><p>The experiment name and where the synthetic observations will be saved.</p><pre><code class="language-julia hljs">experiment_name = &quot;baroclinic_adjustment&quot;
data_path = experiment_name * &quot;.jld2&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;baroclinic_adjustment.jld2&quot;</code></pre><p>The domain, number of grid points, and other parameters.</p><pre><code class="language-julia hljs">architecture = CPU()      # CPU or GPU?
Ly = 1000kilometers       # north-south extent [m]
Lz = 1kilometers          # depth [m]
Ny = 64                   # grid points in north-south direction
Nz = 16                   # grid points in the vertical
Δt = 10minute             # time-step
stop_time = 1days         # length of run
save_interval = 0.25days  # save observation every so often

force_generate_observations = false

anisotropic_diffusivity = AnisotropicDiffusivity(κh=100, κz=1e-2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnisotropicDiffusivity: (νx=0.0, νy=0.0, νz=0.0), (κx=100.0, κy=100.0, κz=0.01)</code></pre><p>The isopycnal skew-symmetric diffusivity closure.</p><pre><code class="language-julia hljs">gerdes_koberle_willebrand_tapering = FluxTapering(1e-2)
gent_mcwilliams_diffusivity = IsopycnalSkewSymmetricDiffusivity(κ_skew = κ_skew,
                                                                κ_symmetric = κ_symmetric,
                                                                slope_limiter = gerdes_koberle_willebrand_tapering)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">IsopycnalSkewSymmetricDiffusivity: (κ_symmetric=900.0, κ_skew=1000.0, (isopycnal_tensor=Oceananigans.TurbulenceClosures.SmallSlopeIsopycnalTensor{Int64}(0), slope_limiter=Oceananigans.TurbulenceClosures.FluxTapering{Float64}(0.01))</code></pre><h2 id="Generate-synthetic-observations"><a class="docs-heading-anchor" href="#Generate-synthetic-observations">Generate synthetic observations</a><a id="Generate-synthetic-observations-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-synthetic-observations" title="Permalink"></a></h2><pre><code class="language-julia hljs">if force_generate_observations || !(isfile(data_path))
    grid = RectilinearGrid(architecture,
                           topology = (Flat, Bounded, Bounded),
                           size = (Ny, Nz),
                           y = (-Ly/2, Ly/2),
                           z = (-Lz, 0),
                           halo = (3, 3))

    closures = (gent_mcwilliams_diffusivity, anisotropic_diffusivity)

    model = HydrostaticFreeSurfaceModel(grid = grid,
                                        tracers = (:b, :c),
                                        buoyancy = BuoyancyTracer(),
                                        coriolis = BetaPlane(latitude=-45),
                                        closure = closures,
                                        free_surface = ImplicitFreeSurface())

    @info &quot;Built $model.&quot;

    ##### Initial conditions of an unstable buoyancy front

    &quot;&quot;&quot;
    Linear ramp from 0 to 1 between -Δy/2 and +Δy/2.

    For example:

    y &lt; y₀           =&gt; ramp = 0
    y₀ &lt; y &lt; y₀ + Δy =&gt; ramp = y / Δy
    y &gt; y₀ + Δy      =&gt; ramp = 1
    &quot;&quot;&quot;
    ramp(y, Δy) = min(max(0, y/Δy + 1/2), 1)

    N² = 4e-6             # [s⁻²] buoyancy frequency / stratification
    M² = 8e-8             # [s⁻²] horizontal buoyancy gradient

    Δy = 50kilometers     # horizontal extent of the font

    Δc_y = 2Δy            # horizontal extent of initial tracer concentration
    Δc_z = 50             # [m] vertical extent of initial tracer concentration

    Δb = Δy * M²          # inital buoyancy jump

    bᵢ(x, y, z) = N² * z + Δb * ramp(y, Δy)
    cᵢ(x, y, z) = exp(-y^2 / 2Δc_y^2) * exp(-(z + Lz/2)^2 / (2Δc_z^2))

    set!(model, b=bᵢ, c=cᵢ)

    simulation = Simulation(model, Δt=Δt, stop_time=stop_time)

    simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),
                                                          schedule = TimeInterval(save_interval),
                                                          prefix = experiment_name,
                                                          array_type = Array{Float64},
                                                          field_slicer = nothing,
                                                          force = true)

    run!(simulation)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Info: Built HydrostaticFreeSurfaceModel{Oceananigans.Architectures.CPU, Float64}(time = 0 seconds, iteration = 0)
│ ├── grid: 1×64×16 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×3×3 halo
│ ├── tracers: (:b, :c)
│ ├── closure: Tuple{Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity{Float64, Float64, Oceananigans.TurbulenceClosures.SmallSlopeIsopycnalTensor{Int64}, Oceananigans.TurbulenceClosures.FluxTapering{Float64}}, Oceananigans.TurbulenceClosures.AnisotropicDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c), Tuple{Float64, Float64}}, NamedTuple{(:b, :c), Tuple{Float64, Float64}}, NamedTuple{(:b, :c), Tuple{Float64, Float64}}}}
│ ├── buoyancy: Oceananigans.BuoyancyModels.Buoyancy{Oceananigans.BuoyancyModels.BuoyancyTracer, Oceananigans.Grids.ZDirection}
│ ├── free surface: Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²
│ │   └── solver: Default
└ └── coriolis: Oceananigans.Coriolis.BetaPlane{Float64}.
[ Info: Initializing simulation...
[ Info:     ... simulation initialization complete (2.428 seconds)
[ Info: Executing initial time step...

[ Info:     ... initial time step complete (1.473 minutes).
[ Info: Simulation is stopping. Model time 1 day has hit or exceeded simulation stop time 1 day.</code></pre><h2 id="Load-truth-data-as-observations"><a class="docs-heading-anchor" href="#Load-truth-data-as-observations">Load truth data as observations</a><a id="Load-truth-data-as-observations-1"></a><a class="docs-heading-anchor-permalink" href="#Load-truth-data-as-observations" title="Permalink"></a></h2><p>We use here the <code>Transformation</code> functionality to slice up the observation data a bit. In particular, we choose to exclude the 3 grid points on either side of the <code>y</code> dimension, and 3 grid points from the bottom of the domain. Also, we only use the last 3 snapshots of the observations.</p><p>We use <code>SpaceIndices</code> and <code>TimeIndices</code> to denote which space-time indices we would like to keep in observations.</p><pre><code class="language-julia hljs">transformation = Transformation(space=SpaceIndices(y=4:Ny-3, z=4:Nz), time=TimeIndices(3:5), normalization=ZScore())
observations = SyntheticObservations(data_path; field_names=(:b, :c), transformation)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SyntheticObservations with fields (:b, :c)
├── times: [0.0, 21600.0, 43200.0, 64800.0, 86400.0]
├── grid: 1×64×16 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×3×3 halo
├── path: &quot;baroclinic_adjustment.jld2&quot;
├── metadata: (:grid, :coriolis, :closure)
└── transformation: Dict{Symbol, OceanTurbulenceParameterEstimation.Transformations.Transformation{TimeIndices{UnitRange{Int64}}, SpaceIndices{Colon, UnitRange{Int64}, UnitRange{Int64}}, ZScore{Float64}}} with 2 entries</code></pre><h2 id="Calibration-with-Ensemble-Kalman-Inversion"><a class="docs-heading-anchor" href="#Calibration-with-Ensemble-Kalman-Inversion">Calibration with Ensemble Kalman Inversion</a><a id="Calibration-with-Ensemble-Kalman-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Calibration-with-Ensemble-Kalman-Inversion" title="Permalink"></a></h2><h3 id="Ensemble-model"><a class="docs-heading-anchor" href="#Ensemble-model">Ensemble model</a><a id="Ensemble-model-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-model" title="Permalink"></a></h3><p>First we set up an ensemble model,</p><pre><code class="language-julia hljs">ensemble_size = 20

slice_ensemble_size = SliceEnsembleSize(size=(Ny, Nz), ensemble=ensemble_size)

@show ensemble_grid = RectilinearGrid(architecture,
                                      size=slice_ensemble_size,
                                      topology = (Flat, Bounded, Bounded),
                                      y = (-Ly/2, Ly/2),
                                      z = (-Lz, 0),
                                      halo=(3, 3))

gm_ensemble = [deepcopy(gent_mcwilliams_diffusivity) for i = 1:ensemble_size]
closures = (gm_ensemble, anisotropic_diffusivity)

@show ensemble_model = HydrostaticFreeSurfaceModel(grid = ensemble_grid,
                                                   tracers = (:b, :c),
                                                   buoyancy = BuoyancyTracer(),
                                                   coriolis = BetaPlane(latitude=-45),
                                                   closure = closures,
                                                   free_surface = ImplicitFreeSurface())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HydrostaticFreeSurfaceModel{Oceananigans.Architectures.CPU, Float64}(time = 0 seconds, iteration = 0) 
├── grid: 20×64×16 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×3×3 halo
├── tracers: (:b, :c)
├── closure: Tuple{Vector{Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity{Float64, Float64, Oceananigans.TurbulenceClosures.SmallSlopeIsopycnalTensor{Int64}, Oceananigans.TurbulenceClosures.FluxTapering{Float64}}}, Oceananigans.TurbulenceClosures.AnisotropicDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c), Tuple{Float64, Float64}}, NamedTuple{(:b, :c), Tuple{Float64, Float64}}, NamedTuple{(:b, :c), Tuple{Float64, Float64}}}}
├── buoyancy: Oceananigans.BuoyancyModels.Buoyancy{Oceananigans.BuoyancyModels.BuoyancyTracer, Oceananigans.Grids.ZDirection}
├── free surface: Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²
│   └── solver: Default
└── coriolis: Oceananigans.Coriolis.BetaPlane{Float64}</code></pre><p>and then we create an ensemble simulation:</p><pre><code class="language-julia hljs">ensemble_simulation = Simulation(ensemble_model; Δt, stop_time)

ensemble_simulation</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulation{typename(Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel){typename(Oceananigans.Architectures.CPU), Float64}}
├── Model clock: time = 0 seconds, iteration = 0
├── Next time step: 10 minutes
├── Elapsed wall time: 0 seconds
├── Stop time: 1 day
├── Stop iteration : Inf
├── Wall time limit: Inf
├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:
│   ├── stop_time_exceeded =&gt; typename(Oceananigans.Simulations.Callback)
│   ├── stop_iteration_exceeded =&gt; typename(Oceananigans.Simulations.Callback)
│   ├── wall_time_limit_exceeded =&gt; typename(Oceananigans.Simulations.Callback)
│   └── nan_checker =&gt; typename(Oceananigans.Simulations.Callback)
├── Output writers: typename(OrderedCollections.OrderedDict) with no entries
└── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries</code></pre><h3 id="Free-parameters"><a class="docs-heading-anchor" href="#Free-parameters">Free parameters</a><a id="Free-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Free-parameters" title="Permalink"></a></h3><p>We construct some prior distributions for our free parameters. We found that it often helps to constrain the prior distributions so that neither very high nor very low values for diffusivities can be drawn out of the distribution.</p><pre><code class="language-julia hljs">priors = (κ_skew = ScaledLogitNormal(bounds=(400.0, 1300.0)),
          κ_symmetric = ScaledLogitNormal(bounds=(700.0, 1700.0)))

free_parameters = FreeParameters(priors)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FreeParameters with 2 parameters
├── names: (:κ_skew, :κ_symmetric)
└── priors: Dict{Symbol, Any}
    ├──      κ_skew =&gt; ScaledLogitNormal{Float64}(μ=0.0, σ=1.0, lower_bound=400.0, upper_bound=1300.0)
    └── κ_symmetric =&gt; ScaledLogitNormal{Float64}(μ=0.0, σ=1.0, lower_bound=700.0, upper_bound=1700.0)</code></pre><p>To visualize the prior distributions we randomly sample out values from then and plot the p.d.f.</p><pre><code class="language-julia hljs">using CairoMakie
using OceanTurbulenceParameterEstimation.Parameters: unconstrained_prior, transform_to_constrained

samples(prior) = [transform_to_constrained(prior, x) for x in rand(unconstrained_prior(prior), 10000000)]

samples_κ_skew = samples(priors.κ_skew)
samples_κ_symmetric = samples(priors.κ_symmetric)

fig = Figure()
ax = Axis(fig[1, 1], xlabel = &quot;Diffusivities [m² s⁻¹]&quot;, ylabel = &quot;PDF&quot;)
densities = []
push!(densities, density!(ax, samples_κ_skew))
push!(densities, density!(ax, samples_κ_symmetric))
Legend(fig[1, 2], densities, [&quot;κ_skew&quot;, &quot;κ_symmetric&quot;], position = :lb)</code></pre><p><img src="../visualize_prior_diffusivities_baroclinic_adjustment.svg" alt/></p><h3 id="The-inverse-problem"><a class="docs-heading-anchor" href="#The-inverse-problem">The inverse problem</a><a id="The-inverse-problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-inverse-problem" title="Permalink"></a></h3><p>We can construct the inverse problem <span>$y = G(θ) + η$</span>. Here, <span>$y$</span> are the <code>observations</code> and <span>$G$</span> is the <code>ensemble_model</code>.</p><pre><code class="language-julia hljs">calibration = InverseProblem(observations, ensemble_simulation, free_parameters)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">InverseProblem{ConcatenatedOutputMap}
├── observations: SyntheticObservations of (:b, :c) on 1×64×16 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×3×3 halo
├── simulation: Simulation on 20×64×16 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×3×3 halo with Δt=600.0
├── free_parameters: (:κ_skew, :κ_symmetric)
└── output map: ConcatenatedOutputMap</code></pre><h3 id="Assert-that-G(θ_*)-y"><a class="docs-heading-anchor" href="#Assert-that-G(θ_*)-y">Assert that <span>$G(θ_*) ≈ y$</span></a><a id="Assert-that-G(θ_*)-y-1"></a><a class="docs-heading-anchor-permalink" href="#Assert-that-G(θ_*)-y" title="Permalink"></a></h3><p>As a sanity check we apply the <code>forward_map</code> on the calibration after we initialize all ensemble members with the true parameter values. We then confirm that the output of the <code>forward_map</code> matches the observations to machine precision.</p><pre><code class="language-julia hljs">G = forward_map(calibration, θ★)
y = observation_map(calibration)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Initializing simulation...
[ Info:     ... simulation initialization complete (838.315 ms)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (1.016 minutes).
[ Info: Simulation is stopping. Model time 1 day has hit or exceeded simulation stop time 1 day.</code></pre><p>The <code>forward_map</code> output <code>G</code> is a two-dimensional matrix whose first dimension is the size of the state space. Here, after the transformation we applied to the observations, we have that the state space size is <span>$2 \times (N_y - 6) \times (N_z - 3) \times 3$</span>; the 2 comes from the two tracers we used as observations and the 3 comes from only using the last three snapshots of the observations. The second dimension of the <code>forward_map</code> output is the <code>ensemble_size</code>.</p><pre><code class="language-julia hljs">@show size(G) == (2 * (Ny-6) * (Nz-3) * 3, ensemble_size)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Since above we computed <code>G</code> using the true parameters <span>$θ_*$</span>, all columns of the forward map output should be the same as the observations:</p><pre><code class="language-julia hljs">mean(G, dims=2) ≈ y</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Next, we construct an <code>EnsembleKalmanInversion</code> (EKI) object,</p><pre><code class="language-julia hljs">eki = EnsembleKalmanInversion(calibration; noise_covariance = 1e-2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleKalmanInversion
├── inverse_problem: InverseProblem
├── ensemble_kalman_process: EnsembleKalmanProcesses.EnsembleKalmanProcessModule.EnsembleKalmanProcess{Float64, Int64, EnsembleKalmanProcesses.EnsembleKalmanProcessModule.Inversion}
├── mapped_observations: 4524-element Vector{Float64}
├── noise_covariance: 4524×4524 Matrix{Float64}
├── inverting_forward_map: OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.var&quot;#inverting_forward_map#4&quot;
├── iteration: 0
├── resampler: Resampler{FullEnsembleDistribution}├── unconstrained_parameters: Matrix{Float64}
└── forward_map_output: Matrix{Float64}</code></pre><p>and perform few iterations to see if we can converge to the true parameter values.</p><pre><code class="language-julia hljs">params = iterate!(eki; iterations = 5)

@show params</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(κ_skew = 1008.4223634998161, κ_symmetric = 896.9188113575574)</code></pre><p>Last, we visualize few metrics regarding how the EKI calibration went about.</p><pre><code class="language-julia hljs">θ̅(iteration) = [eki.iteration_summaries[iteration].ensemble_mean...]
varθ(iteration) = eki.iteration_summaries[iteration].ensemble_var

weight_distances = [norm(θ̅(iter) - [θ★[1], θ★[2]]) for iter in 1:eki.iteration]
output_distances = [norm(forward_map(calibration, θ̅(iter))[:, 1] - y) for iter in 1:eki.iteration]
ensemble_variances = [varθ(iter) for iter in 1:eki.iteration]

f = Figure()
lines(f[1, 1], 1:eki.iteration, weight_distances, color = :red, linewidth = 2,
      axis = (title = &quot;Parameter distance&quot;,
              xlabel = &quot;Iteration&quot;,
              ylabel=&quot;|θ̅ₙ - θ⋆|&quot;,
              yscale = log10))
lines(f[1, 2], 1:eki.iteration, output_distances, color = :blue, linewidth = 2,
      axis = (title = &quot;Output distance&quot;,
              xlabel = &quot;Iteration&quot;,
              ylabel=&quot;|G(θ̅ₙ) - y|&quot;,
              yscale = log10))
ax3 = Axis(f[2, 1:2], title = &quot;Parameter convergence&quot;,
           xlabel = &quot;Iteration&quot;,
           ylabel = &quot;Ensemble variance&quot;,
           yscale = log10)

for (i, pname) in enumerate(free_parameters.names)
    ev = getindex.(ensemble_variances, i)
    lines!(ax3, 1:eki.iteration, ev / ev[1], label = String(pname), linewidth = 2)
end

axislegend(ax3, position = :rt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Initializing simulation...
[ Info:     ... simulation initialization complete (875.440 μs)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (9.536 ms).
[ Info: Simulation is stopping. Model time 1 day has hit or exceeded simulation stop time 1 day.
[ Info: Initializing simulation...
[ Info:     ... simulation initialization complete (950.644 μs)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (9.550 ms).
[ Info: Simulation is stopping. Model time 1 day has hit or exceeded simulation stop time 1 day.
[ Info: Initializing simulation...
[ Info:     ... simulation initialization complete (688.131 μs)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (8.720 ms).
[ Info: Simulation is stopping. Model time 1 day has hit or exceeded simulation stop time 1 day.
[ Info: Initializing simulation...
[ Info:     ... simulation initialization complete (762.435 μs)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (9.145 ms).
[ Info: Simulation is stopping. Model time 1 day has hit or exceeded simulation stop time 1 day.
[ Info: Initializing simulation...
[ Info:     ... simulation initialization complete (821.738 μs)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (9.256 ms).
[ Info: Simulation is stopping. Model time 1 day has hit or exceeded simulation stop time 1 day.</code></pre><p><img src="../summary_baroclinic_adjustment.svg" alt/></p><p>And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.</p><pre><code class="language-julia hljs">f = Figure()

axtop = Axis(f[1, 1])

axmain = Axis(f[2, 1],
              xlabel = &quot;κ_skew [m² s⁻¹]&quot;,
              ylabel = &quot;κ_symmetric [m² s⁻¹]&quot;)

axright = Axis(f[2, 2])
scatters = []
labels = String[]

for iteration in [0, 1, 2, 5]
    # Make parameter matrix
    parameters = eki.iteration_summaries[iteration].parameters
    Nensemble = length(parameters)
    Nparameters = length(first(parameters))
    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:Nparameters]

    label = iteration == 0 ? &quot;Initial ensemble&quot; : &quot;Iteration $iteration&quot;
    push!(labels, label)
    push!(scatters, scatter!(axmain, parameter_ensemble_matrix))
    density!(axtop, parameter_ensemble_matrix[:, 1])
    density!(axright, parameter_ensemble_matrix[:, 2], direction = :y)
end

vlines!(axmain, [κ_skew], color = :red)
vlines!(axtop, [κ_skew], color = :red)

hlines!(axmain, [κ_symmetric], color = :red)
hlines!(axright, [κ_symmetric], color = :red)

colsize!(f.layout, 1, Fixed(300))
colsize!(f.layout, 2, Fixed(200))

rowsize!(f.layout, 1, Fixed(200))
rowsize!(f.layout, 2, Fixed(300))

Legend(f[1, 2], scatters, labels, position = :lb)

hidedecorations!(axtop, grid = false)
hidedecorations!(axright, grid = false)

xlims!(axmain, 350, 1350)
xlims!(axtop, 350, 1350)
ylims!(axmain, 650, 1750)
ylims!(axright, 650, 1750)
xlims!(axright, 0, 0.025)
ylims!(axtop, 0, 0.025)</code></pre><p><img src="../distributions_baroclinic_adjustment.svg" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lesbrary_catke_calibration/">« CAKTE calibration with Ensemble Kalman Inversion using LESbrary data</a><a class="docs-footer-nextpage" href="../../library/outline/">Contents »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 8 February 2022 01:30">Tuesday 8 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
